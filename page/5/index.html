<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="小磊砸的布劳格">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="小磊砸的布劳格">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小磊砸的布劳格">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>小磊砸的布劳格</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小磊砸的布劳格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/08/java-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/08/java-2/" itemprop="url">关键词笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-08T23:33:28+08:00">
                2018-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/08/java-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/08/java-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h1><p>主要用于修饰已支持序列化的类的属性，表明该属性不支持序列化。<br><strong>不想在网络传输中涉及的敏感信息或者一些信息不想被持久化，这些信息只想存在于使用法的内存中。</strong></p>
<ul>
<li>transient修饰实例变量。  </li>
<li>静态变量，不用transient修饰也是无法支持序列化的。  </li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://blog.csdn.net/u013207877/article/details/52572975" target="_blank" rel="noopener">https://blog.csdn.net/u013207877/article/details/52572975</a></p>
</blockquote>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>多线程会共享JVM的堆空间，对于共享资源都在JVM的主堆空间中，而多线程之间的共享资源，都会在线程自己的工作空间中有一份拷贝副本。volatile关键词的作用是对于多线程不再工作空间拷贝主堆空间的共享资源，而是直接使用主堆中的共享资源，这样解决了多线程并发时共享资源的可见性。</p>
<blockquote>
<p>根据编译器优化原则，如果不使用volatile申明变量，那么这个变量被修改后，其他线程可能并不会被通知到，甚至在别的线程中，看到变量的顺序都会是反的。但一旦使用volatile，虚拟机就会特别小心地处理这种情况。</p>
</blockquote>
<p>感觉volatile关键词主要保证了共享资源在多线程中的可见性，对有序性也有所帮助。</p>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《实战java 高并发程序设计》葛一鸣 郭超 编著</p>
</blockquote>
<h1 id="synchronzied"><a href="#synchronzied" class="headerlink" title="synchronzied"></a>synchronzied</h1><blockquote>
<p>指定对象加锁：进入同步代码块钱要活的给定对象的锁。<br>直接作用于实例方法：相当于对当前实例加锁，进入同步代码块前要获得当前实例的锁。<br>直接作用于静态方法：相当于对当前类加锁，进入同步代码块钱要获得当前类的锁。</p>
</blockquote>
<p>前两点都好理解，对于修饰静态方法的场景，这种就符合在多线程并发的时候，多线程共享的如果不是同一个对象但是同一种类型的时候，可以直接修饰在静态方法上，这样也能让线程有序执行。</p>
<h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《实战java 高并发程序设计》葛一鸣 郭超 编著<br>synchronized关键词：<a href="https://blog.csdn.net/mingyundezuoan/article/details/79264644" target="_blank" rel="noopener">https://blog.csdn.net/mingyundezuoan/article/details/79264644</a><br>synchronized与happen-before：<a href="https://www.jianshu.com/p/d53bf830fa09" target="_blank" rel="noopener">https://www.jianshu.com/p/d53bf830fa09</a>  </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/07/concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/07/concurrency/" itemprop="url">高并发基础概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-07T23:50:58+08:00">
                2018-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/07/concurrency/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/07/concurrency/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h1><ul>
<li>同步：调用方必须阻塞等待方法的返回后方可继续执行后续操作。</li>
<li>异步：调用方调用后无需等待方法的返回，方法会在另一个线程去执行，整个异步执行的过程是不会影响调用法的继续工作。  </li>
</ul>
<h1 id="并发（Concurrency-并行（Parallelism）"><a href="#并发（Concurrency-并行（Parallelism）" class="headerlink" title="并发（Concurrency)/并行（Parallelism）"></a>并发（Concurrency)/并行（Parallelism）</h1><p><img src="/2018/09/07/concurrency/concurrency-parallelism.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示：  </p>
<ul>
<li>并发：多个任务交替执行。<strong>逻辑上的同时执行</strong>。  </li>
<li>并行：多个任务同时执行。<strong>物理上的同时执行</strong>。</li>
</ul>
<h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>可被多个线程共享的资源。但是临界区的资源每次只能被一个线程独占。一旦临界区资源已被占用，其余线程只能等待。</p>
<h1 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h1><p>描述多线程的一种并发级别。  </p>
<ul>
<li>阻塞：有线程进入临界区资源，其余的线程想要进入临界区，只能等待，等待会导致线程挂起。这种会有线程挂起的并发场景就是阻塞。</li>
<li>非阻塞：即多线程并发时不会有线程导致其他线程挂起。</li>
</ul>
<h1 id="死锁-饥饿-活锁"><a href="#死锁-饥饿-活锁" class="headerlink" title="死锁/饥饿/活锁"></a>死锁/饥饿/活锁</h1><ul>
<li>死锁：每个线程都拥有别的线程继续执行的资源而有无法释放已拥有的资源，导致线程之间互相等待。</li>
<li>饥饿：时有的线程总是无法获取临界区资源，导致其无法继续执行。</li>
<li>活锁：线程间保持‘谦让’,即每个线程都主动释放临界资源，而导致资源在线程间来回跳动，<strong>没有一个线程可以同时拿到所有的资源继续执行</strong>。</li>
</ul>
<h1 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h1><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><ul>
<li><strong>阻塞要求只有一个线程能够进入临界区</strong></li>
</ul>
<p>线程在执行前，都需要先对临界区进行加锁，而其他线程由于临界区加锁而无法继续执行导致挂起。我们常用的synchronized和ReetranLock都是阻塞锁。  </p>
<h2 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h2><ul>
<li><strong>无饥饿要求每个线程都能有机会进入临界区</strong></li>
</ul>
<p>线程之间的优先级会导致并发的时候产生饥饿问题，而无饥饿的并发级别是指使用公平锁，即所有的线程都是平等的没有优先级的。  </p>
<h2 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h2><ul>
<li><strong>无障碍要求多线程并发时至少有一个线程能成功执行（走出临界区）。</strong>  </li>
<li><strong>无障碍的并发级别可行的方案就是采用CAS策略。</strong></li>
</ul>
<p>每个线程都可以访问临界区资源，都可以做修改，但是修改提交时有可能因为临界区资源已被修改导致的冲突而回滚。即线程提交修改时如果没有冲突则成功提交否则需要回滚修改，直到提交成功才可以走出临界区。<br>无障碍是一种乐观锁，这种乐观锁的极端情况就是可能没有一个线程能够成功提交修改，都在不停的回滚。  </p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><ul>
<li><strong>要求至少一个线程能在有限步内走出临界区</strong></li>
<li><strong>其余线程可以饥饿。</strong></li>
</ul>
<p>一般无锁的调用会采用一个死循环，不断尝试提交修改，如果总是不能成功提交，则产生饥饿，如果成功提交，则满足在有限步内走出临界区。  </p>
<h2 id="无等待"><a href="#无等待" class="headerlink" title="无等待"></a>无等待</h2><ul>
<li><strong>要求每个线程都能在有限步内走出临界区</strong>。</li>
</ul>
<p>常用的方式是<strong>RCU(Read Copy Update)</strong>，即对读操作的线程不加锁，这样所有的读操作线程不会阻塞也不会冲突，而对于写线程在修改数据的时候，先获取数据的副本，修改数据的副本，等待合适的时机将副本数据回写同步到数据。这样写线程也没有阻塞和冲突也都能在有限步内完成工作走出临界区。</p>
<h1 id="高并发操作的线程要求"><a href="#高并发操作的线程要求" class="headerlink" title="高并发操作的线程要求"></a>高并发操作的线程要求</h1><p><img src="/2018/09/07/concurrency/memory.png" alt="包装生成线程安全的hashmap"><br>如图所示，jvm中多线程的内存模型。在jvm中多线程都是共享堆空间。每一个线程都有自己的内存空间。每一个线程内存空间有共享资源的副本。<br>个人理解：<strong>基于RCU原理，线程每次对共享资源的修改其实都是在修改线程内共享资源的副本，为了使得共享资源能够在多线程中共享，需要考虑能够让线程内的副本的修改同步到主内存的共享资源，其余资源也要能知道共享资源发生变化，这就是需要考虑线程的可见性。</strong></p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>共享资源在被多线程并发操作的时候，每一个线程的操作都必须是原子的，共享资源的结果不会在一个线程做操作的时候因为收到别的线程而导致错误。</p>
<blockquote>
<p>比方说共享的对象是Long型的数据，多线程对其累加修改数据，在32位的系统中，对Long型的数据修改不具备原子性，有可能一个线程只修改这个64位数据的其中32位，而另一个线程则读取了修改了一半的数据，进行累加，这个结果势必就是错误的。这种错误的数据就是因为两个线程对数据的操作没有达到原子性。</p>
</blockquote>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>多线程并发时，一旦有线程修改了共享数据，其余线程能够立刻知道修改。</p>
<ul>
<li><strong>可以通过volatile来修饰共享数据，这样保证多线程之前数据的可见性</strong>。</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>jvm因为效率的问题，会发生指令重排，即实际执行的指令顺序与编写的代码顺序可能会不一致。而为了能够让多线程并发时的顺序符合我们的预期，则需要多线程能够有序执行，需要满足<strong>happen-before原则</strong>。</p>
<h3 id="happen-before原则（保证有序性）"><a href="#happen-before原则（保证有序性）" class="headerlink" title="happen-before原则（保证有序性）"></a>happen-before原则（保证有序性）</h3><ul>
<li>程序顺序原则：一个线程内保证语义的串行性。</li>
<li>volatile规则：volatile的写优先于读，这保证了volatile变量在多线程中的可见性。</li>
<li>锁规则：解锁必然发生在随后的加锁前（不会将加锁指令重排到解锁之前）。</li>
<li>传递性：A先于B，B先于C，则A先于C。</li>
<li>线程的start()优先于它的每一个动作。</li>
<li>线程的所有操作优先于线程的终结。</li>
<li>线程的终中断先于被中断线程的代码（现有线程中断，才有线程被中断）。</li>
<li>对象的构造优先于finalize。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>《实战java 高并发程序设计》葛一鸣 郭超 编著<br>死锁：<a href="https://blog.csdn.net/changfengxia/article/details/80313822" target="_blank" rel="noopener">https://blog.csdn.net/changfengxia/article/details/80313822</a><br>活锁：<a href="https://blog.csdn.net/yysct2005/article/details/38581395" target="_blank" rel="noopener">https://blog.csdn.net/yysct2005/article/details/38581395</a>    </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/CAS策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/CAS策略/" itemprop="url">CAS策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T22:33:08+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/06/CAS策略/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/06/CAS策略/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通常为了保护临界区资源的安全访问，都会通过synchronized或者ReetranLock来对资源先进行加锁。这种悲观锁会导致没有获得锁的线程阻塞。将并行改为串行，大大降低了系统的吞吐量。<br><strong>CAS(Compare and Swap)即比较交换</strong>。是无锁安全访问临界资源的一种策略。其假设访问临界资源不会有冲突，多线程对临界资源的访问无需加锁也无需等待阻塞。<strong>每个线程都可以访问临界区资源，也都可以对临界区资源进行修改，但修改不能提交。需要通过CAS算法来甄别是否有冲突，如果没有，则提交修改，如果有则重复当前操作直到没有冲突为止。</strong></p>
<h1 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h1><p>CAS参数：  </p>
<ul>
<li>V要更新的变量值</li>
<li>E该变量的期待值  </li>
<li>N该变量的新值<br>只有当 V = E 的时候，才会将V更新到N，如果V != E，则表明该变量已被修改。本次修改无法提交。</li>
</ul>
<h1 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h1><p>jdk中有一个atomic包来支持CAS处理并发操作。</p>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><ul>
<li>Unsafe提供了一系列原子性的方法来支撑CAS策略，很多数据结构例如AtomicInteger，ConcurrentLinkedQueue等，都是通过Unsafe的原子性操作来支持并发操作。</li>
<li>Unsafe底层是使用C++来实现的，并且JDK也不建议开人人员直接使用unsafe来操作。</li>
</ul>
<p><img src="/2018/09/06/CAS策略/unsafe.png" alt="包装生成线程安全的hashmap"></p>
<blockquote>
<p>当调用Unsafe.getUnsafe()方法来获取Unsafe的时候会对调用方的类加载器进行检查。一般应用的类加载器都是由AppLoader来加载，而系统代码的加载都是由Bootstrap来加载，通过Bootstrap来加载的时候getClassLoader会返回空，而通过AppLoader加载的非空，这样就拒绝了开发人员在代码中自行获取Unsfae。</p>
</blockquote>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p><img src="/2018/09/06/CAS策略/atomicinteger源码.png" alt="包装生成线程安全的hashmap"></p>
<p>如图是AtomicInteger的源码，可以看到实际存储数据的value和CAS策略实际实现Unsafe。  </p>
<ul>
<li>value字段是被volatile关键词修饰的，这样可以保证在多线程并发操作时数据的可见性。  </li>
<li>valueOffset value数据位于AtomicInteger对象中的偏移量。实际对数据的获取以及修改都是基于偏移量来获取的，直接通过偏移量来处理个人理解应该是比较高效。</li>
</ul>
<p><img src="/2018/09/06/CAS策略/atomicinteger.png" alt="包装生成线程安全的hashmap"></p>
<p>如图，是通过AtomicInteger来处理1000个并发线程处理将一个初始值0自增的过程。每个线程调用方法getAndIncrement来实现对临界资源进行自增。输出结果为1000显示整个并发操作的线程安全。<br>除了样例中的方法，AtomicInteger常用的方法如下表：  </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>get()</td>
<td>获取当前值</td>
</tr>
<tr>
<td>set(int newValue)</td>
<td>设置当前值</td>
</tr>
<tr>
<td>int getAndSet(int newValue)</td>
<td>设置新值并返回旧值</td>
</tr>
<tr>
<td>boolean compareAndSet(int expect,int newValue)</td>
<td>如果当前值为except，则更新为newValue</td>
</tr>
<tr>
<td>int getAndIncreament()</td>
<td>自增1，返回旧值</td>
</tr>
<tr>
<td>int getAndDecrement()</td>
<td>自减1，返回旧值</td>
</tr>
<tr>
<td>int getAndAdd(int data)</td>
<td>增加data，返回旧值</td>
</tr>
<tr>
<td>int increamentAndGet()</td>
<td>自增1并返回新值</td>
</tr>
<tr>
<td>int decrementAndGet()</td>
<td>自减1并返回新值</td>
</tr>
<tr>
<td>int addAndGet(int data)</td>
<td>增加data并返回新值</td>
</tr>
</tbody>
</table>
<h2 id="AtomicStampedReference（解决AAB问题）"><a href="#AtomicStampedReference（解决AAB问题）" class="headerlink" title="AtomicStampedReference（解决AAB问题）"></a>AtomicStampedReference（解决AAB问题）</h2><p>CAS策略在控制并发的时候很重要的一点是将期望值与当前值进行比对。如果一致则认为没有其他线程修改，当前修改可以提交，但如果数据从A修改为B又被修改为A，实际是发生了修改但数据一致，如果业务需求需要并发控制的时候不仅仅是通过数值的一致来判断，那么就需要使用到AtomicStampedReference，<strong>即每次修改的时候不仅仅是修改value数据区域，同时还有时间戳，每次进行比对的时候也不仅仅是比对value，还要比对时间戳。只有当时间戳和value都符合期望的时候，修改可以提交。</strong></p>
<p><img src="/2018/09/06/CAS策略/atomicstampedreference.png" alt="包装生成线程安全的hashmap"></p>
<p>如图中源码的compareAndSet方法，除了expectValue，还有expectStamped。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="/2018/09/06/CAS策略/other.png" alt="包装生成线程安全的hashmap"></p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><blockquote>
<p> 网络博客：<a href="https://blog.csdn.net/liubenlong007/article/details/53761730" target="_blank" rel="noopener">https://blog.csdn.net/liubenlong007/article/details/53761730</a><br>《实战java 高并发程序设计》葛一鸣 郭超 编著</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/collect-线程安全的hashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/collect-线程安全的hashmap/" itemprop="url">线程安全的HashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T23:28:24+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/collect-线程安全的hashmap/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/collect-线程安全的hashmap/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p><img src="/2018/09/05/collect-线程安全的hashmap/hashtable.png" alt="hashtable">  </p>
<p>HashTable是线程安全的map，其对所有的get/put方法都通过synchronized关键词来保证线程安全。由于关键词synchronized修饰的是方法，所以线程在执行get/put操作时都会需要获取到这个map对象锁。效率低</p>
<h1 id="Collections-synchronizedMap"><a href="#Collections-synchronizedMap" class="headerlink" title="Collections.synchronizedMap"></a>Collections.synchronizedMap</h1><p><img src="/2018/09/05/collect-线程安全的hashmap/包装.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示，通过Collections.synchronizedMap可以将hashmap包装成一个线程安全的hashmap。</p>
<p><img src="/2018/09/05/collect-线程安全的hashmap/synchronizedmap.png" alt="包装生成线程安全的hashmap"></p>
<p>对于synchronziedMap其实也是基于synchronized来保证的线程安全性，在所有的方法操作之前都需要获取mutex对象锁。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="1-7版"><a href="#1-7版" class="headerlink" title="1.7版"></a>1.7版</h2><p><img src="/2018/09/05/collect-线程安全的hashmap/concurrenthashmap.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示，concurrenthashmap主要由segemtn,entry和链表构成。concurrenthashmap本质是一个segment数组，每一个segment对应着一个Entry数组，Entry数组中的每一个Entry节点都是一个单向链表的头节点。</p>
<h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><p>Segment继承自<strong>ReentranLock</strong>。故Segment其实就是一个锁，Segment是其对应的Entry数组(table)的线程安全的保证。即每当要对Segment对应的table进行操作首先要对Segment加锁。  </p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>每一个Segment都有一个count属性，被<strong>volatile</strong>修饰的。这样每当有线程造成对table的结构性修改都会立即可见。其记录着Segment所包含的HashEntry个数，</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>每一个Segment对应着一个table，被<strong>volatile</strong>修饰。这样每当有线程造成对table的结构性修改都会立即可见。</p>
<h3 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V value;</span><br><span class="line">        final  volatile HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>
<p>HashEntry是Segment中的所有元素的抽象。其value和next都是由volatile修饰的，<strong>由于value和next都被volatile修饰，故每次线程都能读取到最新的数据，所以concurrenthashmap的读操作并没有加锁</strong>。<br>由于next被final修饰，故当有冲突时，节点都从链表的头插入，</p>
<h3 id="concurrencyLevel"><a href="#concurrencyLevel" class="headerlink" title="concurrencyLevel"></a>concurrencyLevel</h3><p>并发度就是concurrenthashmap理想可以支持并发线程数，即Segment的个数。<strong>concurrencyLevel默认是16，concurrentHashMap理想支持16个线程并发操作</strong>。</p>
<h3 id="计算key所在的Segment位置"><a href="#计算key所在的Segment位置" class="headerlink" title="计算key所在的Segment位置"></a>计算key所在的Segment位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Returns the segment that should be used for key with given hash</span><br><span class="line">  * @param hash the hash code for the key</span><br><span class="line">  * @return the segment</span><br><span class="line">  */</span><br><span class="line"> final Segment&lt;K,V&gt; segmentFor(int hash) &#123;</span><br><span class="line">     return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>方法segmentFor就是根据key的hash值来计算key所处的Segment位置，其中SegmentShift=log(size)以2为底。segmentMask=concurrencyLevel-1。</p>
<h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p><img src="/2018/09/05/collect-线程安全的hashmap/concurrencyhashmap1.8.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示。在JDK1.8版本中，对ConcurrentHashMap做了很大的调整。去除了Segment分段锁的设计。采用Node结构，结合单向链表和红黑树来解决冲突（当冲突链表中数据个数大于8个自动将链表转化成红黑树，<strong>查询效率有O(n)降低到O(logn)</strong>，当红黑树的节点个数小于6再转化成链表）。</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">   final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">   	  //参数盘空</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       //重算key的哈希值</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">       //死循环，直到成功put才会结束循环（配合CAS策略）</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">           //如果table为空，则初始化table，concurrenthashmap的构造函数并不会初始化</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">               tab = initTable();</span><br><span class="line">           //如果指定位置为空，则表明没有发生冲突，直接在table中增加节点（tabAt和casTabAt都是通过Unsafe的CAS操作）</span><br><span class="line">           else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">               if (casTabAt(tab, i, null,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                   break;                   // no lock when adding to empty bin</span><br><span class="line">           &#125;</span><br><span class="line">           //正在扩容，则帮助扩容。</span><br><span class="line">           else if ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           else &#123;</span><br><span class="line">               V oldVal = null;</span><br><span class="line">               //对指定位置的Node（头节点）加锁（注意使用的是synchronized来加锁）</span><br><span class="line">               synchronized (f) &#123;</span><br><span class="line">                   //比较头节点</span><br><span class="line">                   if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       if (fh &gt;= 0) &#123;</span><br><span class="line">                           binCount = 1;</span><br><span class="line">                           //遍历链表，找到尾部插入新节点</span><br><span class="line">                           for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               if (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   if (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               if ((e = e.next) == null) &#123;</span><br><span class="line">                                   pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, null);</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       //遍历红黑树，插入新节点</span><br><span class="line">                       else if (f instanceof TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = 2;</span><br><span class="line">                           if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != null) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               if (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               //如果链表的节点数达到需要转换成红黑树的阀值，在转换成红黑树</span><br><span class="line">               if (binCount != 0) &#123;</span><br><span class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   if (oldVal != null)</span><br><span class="line">                       return oldVal;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(1L, binCount);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过put方法的源码可以发现：  </p>
<ul>
<li>通过synchronized来对链表的头节点Node进行加锁。而没有使用1.7版本中的ReentranLock。  </li>
<li>整个concurrentHashMap的初始化是发生在第一次put的时候。  </li>
<li>指定位置节点的获取，更新以及增加的操作都是通过Unsafe利用CAS策略来实现的，这种无锁的处理方式减少了因为锁导致的线程阻塞，增大了系统的吞吐量。</li>
</ul>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        //重算key的哈希值</span><br><span class="line">        int h = spread(key.hashCode());</span><br><span class="line">        //获取指定位置的Node（无冲突时链表的头节点）判断如果一致则返回</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">            if ((eh = e.hash) == h) &#123;</span><br><span class="line">                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果是扩容，则通过ForwardingNode查找</span><br><span class="line">            else if (eh &lt; 0)</span><br><span class="line">                return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">            //依次遍历查找</span><br><span class="line">            while ((e = e.next) != null) &#123;</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过get方法的源码，可以看出,get方法并没有加锁。</p>
<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p><img src="/2018/09/05/collect-线程安全的hashmap/8-cas.png" alt="包装生成线程安全的hashmap"></p>
<p>如图中所示，在1.8版的ConcurrentHashMap中还是使用到了CAS策略，通过Unsafe来完成获取指定位置的Node，通过比较交换来设置指定位置的Node以及增加对应位置的Node。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>1.8版本的锁颗粒度更小，只是对Node数组中的Node节点通过synchronized来加锁。而1.7版本中是对整个Segment来加锁。  </li>
<li>1.8中除了通过链表来解决冲突之外，当链表中节点的个数大于8个之后会转换成红黑树，这样使得当有冲突时查找数据的效率由O(n)降低到了O(logn)。<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li>
</ul>
<blockquote>
<p> <a href="https://blog.csdn.net/justloveyou_/article/details/72783008" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/72783008</a><br> <a href="https://blog.csdn.net/bolang789/article/details/79855053" target="_blank" rel="noopener">https://blog.csdn.net/bolang789/article/details/79855053</a><br> <a href="https://blog.csdn.net/fouy_yun/article/details/77816587" target="_blank" rel="noopener">https://blog.csdn.net/fouy_yun/article/details/77816587</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/java-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/java-1/" itemprop="url">PO/BO/VO/POJO/DAO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T16:06:34+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/java-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/java-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PO-VO-BO-DAO-简介"><a href="#PO-VO-BO-DAO-简介" class="headerlink" title="PO/VO/BO/DAO 简介"></a>PO/VO/BO/DAO 简介</h1><h2 id="PO（Presistant-Object）"><a href="#PO（Presistant-Object）" class="headerlink" title="PO（Presistant Object）"></a>PO（Presistant Object）</h2><p>持久化对象，数据库中数据的抽象，即对应表中的一条记录。</p>
<h2 id="BO-Business-Object"><a href="#BO-Business-Object" class="headerlink" title="BO(Business Object)"></a>BO(Business Object)</h2><p>业务对象，可以包含多个其他对象。</p>
<blockquote>
<p>一份简历，包含教育经历，工作经历等，教育经历对应一个PO，工作经历对应一个PO，这样简历BO就由这些PO组成。</p>
</blockquote>
<h2 id="DTO-Data-Transfer-Object"><a href="#DTO-Data-Transfer-Object" class="headerlink" title="DTO(Data Transfer Object)"></a>DTO(Data Transfer Object)</h2><p>数据传输对象，用于前端与后端进行数据交互。由于涉及到网络传输，故DTO会根据展示层的要求来简化数据来减少网络流量。</p>
<blockquote>
<p>比如一个表有20个字段，对应的PO也会有20个字段，界面展现只需要展现5个字段，故只需要DTO包含界面展现的5个字段进行传输即可，相比较传输真个PO，这样减少了网络流量，也不会暴露整个表结构。</p>
</blockquote>
<h2 id="VO-Value-Object"><a href="#VO-Value-Object" class="headerlink" title="VO(Value Object)"></a>VO(Value Object)</h2><p>值对象，常用于前端组件进行数据展现的时候所使用的数据结构。其来自于DTO。</p>
<h2 id="POJO-plain-ordinary-java-object"><a href="#POJO-plain-ordinary-java-object" class="headerlink" title="POJO(plain ordinary java object)"></a>POJO(plain ordinary java object)</h2><p>简单的java对象。普通的javabean。</p>
<h1 id="区别与应用"><a href="#区别与应用" class="headerlink" title="区别与应用"></a>区别与应用</h1><h2 id="VO与DTO"><a href="#VO与DTO" class="headerlink" title="VO与DTO"></a>VO与DTO</h2><p>当展现层的需求只有一种的时候，可以使用DTO来替代VO，在设计层面，DTO只是用来明确服务端接收的请求的数据或者响应请求的数据，而界面展现的时候，特别是当展现的需求多种多样的时候，会基于同一种DTO而衍生出不同的VO。</p>
<blockquote>
<p>比方说性别，DTO中sex是男女，如果普通的展现需求，可以直接利用DTO中的sex属性来展现。但如果有个性化定制的时候，比方说需要展现成帅哥/美女，这种时候基于同样的DTO就需要根据展现的需求来衍生出性别为帅哥/美女的VO。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/collect-hashmap-hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/collect-hashmap-hashtable/" itemprop="url">HashMap与HashTable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T13:49:37+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/collect-hashmap-hashtable/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/collect-hashmap-hashtable/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HasMap"><a href="#HasMap" class="headerlink" title="HasMap"></a>HasMap</h1><ul>
<li>HashMap是基于哈希表实现的。每一个元素都是key-value的键值对。并通过链表来解决冲突问题。  </li>
<li>HashMap是非线程安全的。可以利用<strong>Collections.synchronizedMap</strong>来获取经过线程安全包装的HashMap。  </li>
<li>HashMap实现了Serializable接口，支持克隆。</li>
<li>HashMap默认大小是16（<strong>必须是2的整次幂</strong>），加载因子默认是0.75，即当已使用当前容量的0.75后，HashMap会自动扩容（2倍）。容量大小和加载因子都可以在构造的时候指定。</li>
<li>HashMap允许添加的元素key，value为空。</li>
</ul>
<h2 id="存储逻辑"><a href="#存储逻辑" class="headerlink" title="存储逻辑"></a>存储逻辑</h2><p>HashMap底层是一个Entry的数组。并利用链表来解决冲突，即没有个Entry是链表的头部节点。每一次添加一个key-value元素时，基于key的哈希值和HashMap的大小来计算出元素所位于Entry数组的位置索引（key的哈希值&amp;&amp;0x7FFFFFFF，<strong>为了去除哈希值的符号</strong>，再与size取模），如果两个元素计算出的位置索引一致，则会将元素添加到同一个entry下的链表中。<br><img src="/2018/09/05/collect-hashmap-hashtable/hashmap-struct.png" alt="HashMap存储结构"><br>如图，紫色部分是Enty数组，绿色部分时用来解决冲突的链表。</p>
<h2 id="扩容逻辑"><a href="#扩容逻辑" class="headerlink" title="扩容逻辑"></a>扩容逻辑</h2><p>当HashMap的使用空间=当前容量*加载因子后，HashMap会自动扩容，<br>扩容会新建一个Entry数组，将已有的所有元素都重新计算位置索引并转移到新的Entry数组中。所以扩容会相当的费时。  </p>
<ul>
<li>当加载因子越小，容易进行扩容操作，能使用的空间小，也会造成大量的空间浪费。  </li>
<li>当加载因子越大，不容易进行扩容操作。空间使用率高，但冲突率会加大，链表会很长，这样查询的效率会很低。  </li>
</ul>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul>
<li>HashTable是基于哈希表实现的，也是通过链表来解决冲突。</li>
<li>HashTable是线程安全的。所有操作的方法都有Synchronized关键词修饰。</li>
<li>HashTable也实现了Serizlizable接口，支持克隆。</li>
<li>HashTable默认大小11，加载因子默认也是0.75，自动扩容为（2倍+1）。容量和加载因子可以在构造时指定。</li>
<li>HashTable不允许添加的元素key为空，源码中可以看到，当key为空时，会抛出空指针异常。<br><img src="/2018/09/05/collect-hashmap-hashtable/hashtablecode.png" alt="HashTable源码"></li>
</ul>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="继承父类不同"><a href="#继承父类不同" class="headerlink" title="继承父类不同"></a>继承父类不同</h2><p>HashMap继承自AbstractMap，HashTable继承自Dictionary。但都实现了Map接口。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>HashMap不是线程安全的，而HashTable是线程安全的。</p>
<h2 id="是否提供contains方法"><a href="#是否提供contains方法" class="headerlink" title="是否提供contains方法"></a>是否提供contains方法</h2><p>HashMap提供containsKey和containsValue两个方法，HashTable提供contains,containsKey和containsValue三个方法（containsValue中调用的contains方法）。</p>
<h2 id="key是否允许为null"><a href="#key是否允许为null" class="headerlink" title="key是否允许为null"></a>key是否允许为null</h2><p>HashMap允许key和value为null,HashTable不允许key和value为空。<strong>因此在HashMap中不能通过get方法来判断是否存在某一个key，有可能这个key就是null</strong></p>
<h2 id="哈希值的不同"><a href="#哈希值的不同" class="headerlink" title="哈希值的不同"></a>哈希值的不同</h2><p>HashMap是重新计算key的哈希值，在与0x7FFFFFFF做与运算，去除符号后与size取模来计算元素在Entry数组中的位置索引。HashTable是直接利用key的哈希值来与size取模获取位置索引。</p>
<h2 id="扩容逻辑不同"><a href="#扩容逻辑不同" class="headerlink" title="扩容逻辑不同"></a>扩容逻辑不同</h2><ul>
<li>HashMap默认大小16，HashTable默认大小11.</li>
<li>HashMap每次扩容为原有的2倍，HashTable扩容为原有的2倍+1。  </li>
<li>HashMap要求Entry数组长度必须是2的整次幂，HashTable没有要求。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/http-state-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/http-state-code/" itemprop="url">http状态码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T23:18:03+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/04/http-state-code/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/04/http-state-code/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面试的时候被问到了有关状态码的内容，现整理如下表所示：</p>
<h1 id="正在执行"><a href="#正在执行" class="headerlink" title="正在执行"></a>正在执行</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>正在执行</td>
</tr>
</tbody>
</table>
<h1 id="成功处理请求"><a href="#成功处理请求" class="headerlink" title="成功处理请求"></a>成功处理请求</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td><strong>成功返回</strong></td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>资源已依据请求创建</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td><strong>已接收请求但并未处理，异步执行，可能执行了可能没执行</strong></td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>已处理请求，但返回数据的来源非原始服务器，可能来自本地或第三方的拷贝。即<strong>非授权信息</strong></td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>处理请求后无返回数据</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>处理请求后无返回，但需要请求方需要重置文档视图（浏览器需要重置表单）</td>
</tr>
</tbody>
</table>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>被请求的资源有多个备选的操作供请求者选择，每一个操作都对应一个地址来重定向</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>被请求的资源已被永久的变更到新地址，<strong>使用get请求时会自动重定向</strong></td>
</tr>
<tr>
<td>302</td>
<td>Move temporarily</td>
<td>被请求的资源临时从别的地址来响应，请求者还是通过原有地址来请求</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>请求的资源可以在另一个URI中获取，请求者应该通过一个专门的get请求来获取响应</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>本次请求与上一次的请求，请求的网页没有变化，返回此状态码而不会返回网页数据</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>请求的资源必须通过指定的代理才可以被访问</td>
</tr>
<tr>
<td>306</td>
<td>Temporary Redirect</td>
<td>服务器临时从别的地址来响应请求，请求者还是通过原有地址来请求</td>
</tr>
</tbody>
</table>
<h1 id="请求错误"><a href="#请求错误" class="headerlink" title="请求错误"></a>请求错误</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>Bad Request</td>
<td><strong>请求参数错误/语义错误</strong></td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>需要认证</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>拒绝该请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>未找到指定的资源</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>拒绝请求的方法</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>无法使用请求的内容特性响应请求的网页</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>与401类似，但是需要在代理服务器进行身份认证</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>请求超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器在处理请求时发生冲突，需要返回详细的信息告知请求方冲突的来源</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>请求的资源已永久的不可用（已删除）</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>需要定义content length，即服务器拒绝没有定义有效长度的请求</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>未满足先决条件</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>请求的实体数据太大</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Long</td>
<td>请求的URI超长</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器不支持请求的数据格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable</td>
<td>请求中包含Range,但返回的数据中不符合在范围内</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>请求中包含Except，但服务器无法满足预期</td>
</tr>
<tr>
<td>421</td>
<td>too many connections</td>
<td>服务器的连接数超限</td>
</tr>
<tr>
<td>422</td>
<td>Unprocessable Entity</td>
<td>请求格式正确但含有语义错误</td>
</tr>
<tr>
<td>423</td>
<td>Locked</td>
<td>请求资源被锁定</td>
</tr>
<tr>
<td>424</td>
<td>Failed Dependency</td>
<td>由于之前的请求导致本次请求失败</td>
</tr>
<tr>
<td>451</td>
<td>Unavailable For Legal Reasons</td>
<td>请求因法律原因而不可用</td>
</tr>
</tbody>
</table>
<h1 id="服务器错误"><a href="#服务器错误" class="headerlink" title="服务器错误"></a>服务器错误</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td><strong>服务器端发生异常</strong></td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持该功能，无法识别该请求或者不能支持该请求的资源</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td><strong>网关或者代理服务器在处理请求时，无法从上游服务器获取响应</strong></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td><strong>服务器维护或者过载导致无法处理请求</strong></td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td><strong>网关或代理服务器处理请求时，获取上游服务器响应超时</strong></td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器不支持请求指定的http版本</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/redis-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis-3/" itemprop="url">redis持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T22:16:00+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/redis-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/redis-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis持久化方式"><a href="#Redis持久化方式" class="headerlink" title="Redis持久化方式"></a>Redis持久化方式</h2><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>将某个时刻的数据持久化到硬盘中。用户可以对快照进行备份。支持复制到其他服务器。</p>
<h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><ul>
<li><strong>bgsave</strong> 创建一个快照。<strong>Redis会创建一个子进程来负责将快照写入硬盘。父进程继续接受请求。</strong></li>
<li><strong>save</strong> Redis在快照创建完毕前不会接受任何请求。</li>
<li><strong>shutdown</strong>命令用于停止redis服务的时候会执行一次<strong>save</strong>命令。停止所有请求。</li>
<li><strong>sync</strong>命令进行Redis服务器之间的数据同步的时候。如果主服务器并没有正在进行bgsave或者不是刚刚结束bgsave命令时会执行bgsave命令。</li>
</ul>
<h4 id="快照配置"><a href="#快照配置" class="headerlink" title="快照配置"></a>快照配置</h4><blockquote>
<p>save 60 1000    60秒内有1000次写操作则自动触发bgsave<br>stop-writes-on-bgsave-error-no  当创建快照失败时是否停止写操作<br>rdbcompression yes  是否对快照进行压缩<br>dbfilename dump.rdb 快照名称<br>dr ./   快照文件存储的路径</p>
</blockquote>
<h4 id="快照缺陷"><a href="#快照缺陷" class="headerlink" title="快照缺陷"></a>快照缺陷</h4><ul>
<li>快照是某一个时间点的内存数据备份。如果在服务器崩溃则会丢失上一次快照到崩溃时的所有变更数据。   </li>
<li>快照适合即使丢失一部分少量的数据也不会对整个应用造成问题的场景。   </li>
</ul>
<blockquote>
<p>《Redis实战》中提到的对日志进行聚合计算。没有看懂到底是什么意思。   </p>
</blockquote>
<ul>
<li>当大数据处理时，Redis占用的内存会很大，bgsave创建子进程会耗费一定的时间，这个创建的过程则会导致redis停顿。停顿的时间随着Redis占用内存越大而越久。相比较于创建子进程带来的停顿，save并不会因为要创建子进程而去争抢资源导致停顿。故save会较bgsave的速度更快。</li>
</ul>
<h3 id="AOF-append-only-file"><a href="#AOF-append-only-file" class="headerlink" title="AOF(append-only file)"></a>AOF(append-only file)</h3><p>将写操作的命令追加到备份文件中。等到需要恢复时（重启）从头到尾执行一遍备份文件中的写命令即可。</p>
<h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>随着Redis不断的运行。aof文件会变得越来越大。占用硬盘同时在重启时根据aof重新执行写命令时耗时长。<br><strong>bgrewriteaof</strong> 等同bgsave，会启动子进程来重写aof文件。父进程继续接受请求。</p>
<h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><blockquote>
<p>appendonly yes  是否启用AOF模式<br>appendfsync everrysec 追加的频率。always每次写操作都同步。everysec每秒执行一次同步，可以同步多条写操作。no 由操作系统来决定何时进行同步。<br>no-appendfsync-on-rewrite no<br>auto-aof-rewrite-percentage 100 当aof文件比上一次重写时大了一倍则进行aof文件重写<br>auto-aof-rewrite-min-size 64mb  当aof文件的大小大于64mb时进行aof文件重写<br>dr ./   aof文件存储路径     </p>
</blockquote>
<h4 id="AOF缺陷"><a href="#AOF缺陷" class="headerlink" title="AOF缺陷"></a>AOF缺陷</h4><ul>
<li><strong>bgrewriteaof</strong>命令创建子进程也会由于redis占用的内存越大而创建子进程的时间越长从而导致redis停顿。</li>
<li>对aof文件进行重写时会涉及对旧的aof文件进行删除，如果文件很大很有可能导致操作系统的挂起。</li>
</ul>
<h2 id="持久化的意义"><a href="#持久化的意义" class="headerlink" title="持久化的意义"></a>持久化的意义</h2><ul>
<li>数据重用。redis中很多的数据都是一些经过长时间计算得到的。这样持久化到硬盘中就不必再次计算可以方便下次使用。</li>
<li>安全。将数据备份到硬盘防止因系统崩溃而丢失数据。Redis运行时数据都是存储在内存中，而一旦系统奔溃内存中的数据时很大程度会丢失。  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/redis-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis-2/" itemprop="url">redis笔记二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T22:11:37+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/redis-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/redis-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅/发布模式"></a>订阅/发布模式</h2><blockquote>
<p>一般来说，发布于订阅的特点是订阅者(listener)负责订阅频道(channel)，发送者(publisher)负责向频道发送而今这字符串消息(binary string message)。每当有消息被发送至给定的频道时，频道的所有订阅者都会受到消息。<br>by 《Redis 实战》</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel1 ...] 订阅频道  </span><br><span class="line">unsubscribe [channel [channel1 ...]] 退订频道，**如果未指定channel则默认退订所有频道。**  </span><br><span class="line">publish channel message 向频道channel发送消息  </span><br><span class="line">psubscribe pattern [pattern...] 订阅符合条件的频道  </span><br><span class="line">punsubscribe [pattern [pattern...]] 退订符合条件的频道，**如果没有指定pattern则默认退订所有频道。**</span><br></pre></td></tr></table></figure>
<h3 id="订阅-发布模式的缺陷"><a href="#订阅-发布模式的缺陷" class="headerlink" title="订阅/发布模式的缺陷"></a>订阅/发布模式的缺陷</h3><ul>
<li>系统的缺陷。旧版本的Redis。当订阅的频道消息量很大而自身的读取速度不够时会导致Redis缓冲区体积很大，这样会使得效率很低甚至崩溃。还会被操作系统强杀。新版本的Redis不会有这种问题，需要配置client-output-buffer-limit pubsub来自动断开。  </li>
<li>数据传输的可靠性。在客户端订阅过程中断线，客户端会丢失在断线期间频道的所有消息。</li>
</ul>
<h2 id="事务基本用法"><a href="#事务基本用法" class="headerlink" title="事务基本用法"></a>事务基本用法</h2><blockquote>
<p>Redis有5个命令可以让用户再不被打断的情况下对多个键执行操作，分别是watch、multi、exec、unwatch和discard。<br>Redis基本的事务用法置灰用到multi和exec命令。<br>Redis里执行事务，首先需要执行Multi命令，然后输入那些想要在事务里执行的命令，最后再执行exec命令。当</p>
</blockquote>
<p>Redis从一个客户端那里接收到multi命令时，Redis会将这个客户端之后发送的所有命令都放入到一个队列里，直到这个客户端发送exec命令为止，然后Redis就会在不被打断的情况下，一个接一个地执行存储在队列里地命令。这种事务的执行方式是通过延迟执行事务极大降低了客户端与服务端的通信连接次数来提高性能。是一种<strong>流水线事务。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi 申明后面地指令操作都在同一个事务中。    </span><br><span class="line">exec 申明事务截至，以上地所有操作都在同一个事务中。  </span><br><span class="line">watch 对键进行监控。直到exec命令之间如果有别的连接对受监控的键进行了修改，删除等更新操作，exec命令执行失败并返回错误。  </span><br><span class="line">unwatch 取消对键的监控。在执行multi之前都有效。  </span><br><span class="line">discard	取消对键的监控。在执行exec之前都有效。</span><br></pre></td></tr></table></figure>
<h3 id="Redis没有加锁"><a href="#Redis没有加锁" class="headerlink" title="Redis没有加锁"></a>Redis没有加锁</h3><p>传统数据库会在对数据库进行写操作时对访问的数据进行加锁。直到事务被提交或者回滚。其它客户端对数据进行写入时由于无法拿到数据的锁而阻塞。只有当持有锁的事务执行完毕后释放锁才可以重新执行。这种锁的缺陷是当锁的持有事务执行的时间越久，则其它事务阻塞的时间就越久<strong>（悲观锁）</strong>。<br>Redis为了尽可能的减少客户端阻塞的时间，只有当数据已经抢先被修改更新了，如果有客户段对该数据进行监控(watch)的会进行通知<strong>（乐观锁）</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/redis-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis-1/" itemprop="url">redis笔记一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T22:00:58+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/redis-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/redis-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于之前有匆忙的接触过Redis。有感受到Redis相较于关系型数据库的便捷，快速和高效。便抽空专门边学习边写一些笔记来做一些分享。学习的途径主要是参考书籍《Redis实战》，参考网站 <a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">http://redisdoc.com/index.html</a>  </p>
<blockquote>
<p>Redis是一种NoSQL数据库。可以存储key以及5种数据结构的映射。同时支持将存储在内存中的数据持久化到硬盘中（参考）。<br>by《Redis实战》</p>
</blockquote>
<p>Redis说白了就是一种key-value的数据库。数据由于存储在内存当中有很高的读写性能。其中这种基于key-value的存储结构无须为了考虑表结构而改变数据的结构是相当人性化的。<strong>Redis支持的key是字符串。对于value有String（字符串）、List（列表）、Set（集合）、ZSet（有序集合）和Hash（哈希）总共5种数据接口。</strong></p>
<h2 id="指令操作"><a href="#指令操作" class="headerlink" title="指令操作"></a>指令操作</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#连接服务</span><br><span class="line">redis-cli [-h host] [-p -port] [-a passwd]</span><br><span class="line">#或者连接后再通过auth认证</span><br><span class="line">auth passwd</span><br><span class="line">#查看所有的key</span><br><span class="line">keys *</span><br><span class="line"># 查看key的类型</span><br><span class="line">type keyname</span><br></pre></td></tr></table></figure>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value 	设置指定的键和值  </span><br><span class="line">get key 		获取指定的键值  </span><br><span class="line">del key			删除指定的键</span><br></pre></td></tr></table></figure>
<h4 id="自增和自减运算"><a href="#自增和自减运算" class="headerlink" title="自增和自减运算"></a>自增和自减运算</h4><blockquote>
<p>在Redis中字符串可以存储三种数据  </p>
<ol>
<li>字符串  </li>
<li>整数  </li>
<li>浮点型<br>by 《Redis实战》  </li>
</ol>
</blockquote>
<p><strong>redis支持对字符串进行自增和自减的处理。会自动将字符串进行转换成整型或者浮点型。如果不能进行转换则会返回错误码。如果处理的key并不存在则会默认从0开始走自增和自减处理</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">incr key 对key进行自增  </span><br><span class="line">decr key 对key进行自减  </span><br><span class="line">incrby key value1 对key的value自增value1  </span><br><span class="line">decrby key value2 对key的value自减value2  </span><br><span class="line">incrbyfloat key value3 对key的value自增value3(value3是浮点型数据)。</span><br></pre></td></tr></table></figure>
<p><strong>并没有decrbyfloat命令。</strong></p>
<h4 id="部分读写"><a href="#部分读写" class="headerlink" title="部分读写"></a>部分读写</h4><p>Redis还支持对字符串部分内容进行读写的操作，<strong>这种操作是支持对整型和浮点型数据处理，但不建议这样做。</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">append key value1 向字符串key的value追加value1  </span><br><span class="line">getrange key start end 获取字符串key的value从start到end部分的值（包括start和end位置）  </span><br><span class="line">setrange key offset value1 从offset开始将字符串key的value替换成value1。value1的长度必须小于value从offset开始的长度。</span><br></pre></td></tr></table></figure>
<p><strong>当value的长度不足时会自动将长度增加到符合条件时。即这条指令有追加的功能。</strong> </p>
<h4 id="二进制处理"><a href="#二进制处理" class="headerlink" title="二进制处理"></a>二进制处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset 将字符串作为二进制字符串。获取offset位置二进制的值  </span><br><span class="line">setbit key offset value1 设置二进制字符串key的value中offset位置的二进制值为value1  </span><br><span class="line">bitcount key [start] [end] 统计字符串key的value中二进制位为1的数量。start和end可选  </span><br><span class="line">bitop operator key1 key2 [key3...] destkey 对多个key的value进行二进制运算，运算结果存储在destkey中。运算类型支持并(and)、或（or）、异或（xor）和非（not）。</span><br></pre></td></tr></table></figure>
<h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><p>列表中可以存储多个字符串。同时可以重复。  </p>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lpush key [key1...] 向key的列表左端添加多个字符串。rpush是从右端添加字符串  </span><br><span class="line">lpop key 从key的列表左端删除一个字符串。rpop是从右端删除字符串    </span><br><span class="line">lindex key index 获取key的列表中index位置的字符串  </span><br><span class="line">lrange key start end 获取指定范围列表中的字符串。start=0,end=-1时可以获取列表所有的字符串  </span><br><span class="line">ltrim key start end 保留key的列表从start到end位置的字符串。</span><br></pre></td></tr></table></figure>
<h4 id="列表转移"><a href="#列表转移" class="headerlink" title="列表转移"></a>列表转移</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpoplpush src-list dest-list 从src-list的右端弹出一个元素插入到dest-list的左端。</span><br></pre></td></tr></table></figure>
<p><strong>没有lpoprpush命令</strong>  </p>
<h4 id="阻塞队列操作"><a href="#阻塞队列操作" class="headerlink" title="阻塞队列操作"></a>阻塞队列操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blpop list [list-1 ...] timeout 可以对多个list进行左弹出一个字符串。但是会从左到右处理第一个非空列表。timeout是指当列表为空时会阻塞的时间。  </span><br><span class="line">brpop 同blpop。只是从列表的右端弹出字符串。  </span><br><span class="line">brpoplpush src-list dest-list timeout 从src-list中最右端弹出一个元素添加到dest-list的左端。如果src-list为空则阻塞timeout时长。</span><br></pre></td></tr></table></figure>
<p>对于阻塞队列的操作常用于<strong>消息的传递和任务队列</strong>。</p>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><blockquote>
<p>集合是通过散列的表来保证元素都是不相同的（这些散列表只有键，没有与键对应的值）。<br>by 《Redis 实战》</p>
</blockquote>
<h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sadd set-name item [item-1] 向集合添加元素。支持同时加入多个元素</span><br><span class="line">smembers set-name 获取集合的所有元素。**当集合元素很多时效率很低，谨慎使用**  </span><br><span class="line">sismember set-name item 判断元素是否时集合中的元素</span><br><span class="line">srem set-name item [item-1] 从集合中删除元素。支持同时删除多个元素  </span><br><span class="line">scard set-name 获取集合元素的个数</span><br><span class="line">srandmember set-name [count] 随机返回集合中的元素。count&gt;0时返回的元素不重复。count&lt;0时返回的元素会重复。</span><br><span class="line">spop 随机从元素中删除一个元素</span><br><span class="line">smove src-set dest-set item 如果src-set中包含元素item则从src-set中删除，在dest-set中加入该元素。</span><br></pre></td></tr></table></figure>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sdiff set-name set-name2 [set-name3...] 多个集合的差集  </span><br><span class="line">sdiffstore dest-set set-name set-name2 [set-name3...] 将多个集合的差集存储到dest-set中  </span><br><span class="line">sinner set-name set-name2 [set-name3...] 多个集合的交集  </span><br><span class="line">sinnerstore dest-set set-name set-name2 [set-name3...] 将多个集合的交集存储到dest-set中  </span><br><span class="line">sunion set-name set-name2 [set-name3...] 多个集合的并集</span><br><span class="line">sunionstore dest-set set-name set-name2 [set-name3...] 将多个集合的并集存储到dest-set中</span><br></pre></td></tr></table></figure>
<h3 id="散列操作"><a href="#散列操作" class="headerlink" title="散列操作"></a>散列操作</h3><p>散列可以存储多个键值对。键值对的值同字符串一样，可以是字符串也可以是数字值。同时支持对散列存储的值进行自增处理。</p>
<blockquote>
<p>散列在很多方面就像是一个微缩版的Redis<br>by 《Redis 实战》</p>
</blockquote>
<h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hset map-name key value 向散列map-name中存放键值对key value。  </span><br><span class="line">hget map-name key 获取散列map-name中键key对应的value  </span><br><span class="line">hget map-name 获取散列map-name所有的键值对  </span><br><span class="line">hdel map-name key [key1...] 删除散列map-name中的键key。支持同时删除多个key</span><br><span class="line">hlen map-name 获取散列map-name中键值对的数量  </span><br><span class="line">hexists map-name key 判断散列map-name中是否包含key</span><br></pre></td></tr></table></figure>
<h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><blockquote>
<p>批量处理多个键的命令既可以给用户带来方便，又可以通过减少命令的调用次数以及客户端与redis之间的通讯往返次数来提升redis的性能。<br>by 《Redis 实战》</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hmset map-name key value [key1 value1 ...] 同时向散列map-name中存储多个键值对  </span><br><span class="line">hmget map-name key [key1...] 获取散列map-name中多个key的值  </span><br><span class="line">hkeys map-name 获取散列所有的键  </span><br><span class="line">hvals map-name 获取散列所有的值  </span><br><span class="line">hgetall map-name 获取散列所有的键值对</span><br></pre></td></tr></table></figure>
<h4 id="自增处理"><a href="#自增处理" class="headerlink" title="自增处理"></a>自增处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby map-name key increament 对散列map-name的key对应的值自增increament  </span><br><span class="line">hincrbyfloat map-name key increament 对散列map-name的key对应的值自增increament(浮点型)</span><br></pre></td></tr></table></figure>
<p><strong>对于散列中未存在的key进行自增处理时同样会将value初始作为0开始运算。</strong></p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><blockquote>
<p>有序集合和散列一样，都用于存储键值对:有序集合的键成为成员，每个成员都是各不相同的；而有序集合的值则 被称为分值，分值必须浮点型。<br>有序集合既可以根据成员访问元素，又可以根据分值以及分值的排列顺序来访问元素。<br>by 《Redis实战》</p>
</blockquote>
<h4 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zadd set-name score item [score item ...] 向有序集合添加分值score的成员item  </span><br><span class="line">zrem set-name item [item1...] 删除有序集合中的元素  </span><br><span class="line">zcard set-name 有序集合的成员个数  </span><br><span class="line">zcount set-name min max 获取有序集合分值介于min和max之间的成员</span><br><span class="line">zrank set-name item 获取成员的排名</span><br><span class="line">zrevrank set-name item 获取成员的排名（反序，分值由大到小）</span><br><span class="line">zscore set-name item 获取成员的分值</span><br><span class="line">zincrby set-name item increament 给成员的分值增加increament</span><br></pre></td></tr></table></figure>
<h4 id="基于分值的排名"><a href="#基于分值的排名" class="headerlink" title="基于分值的排名"></a>基于分值的排名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrange set-name start stop [withscores] 获取分值排名在start和stop之间的成员。withscores是返回时带有分值。  </span><br><span class="line">zrevrange set-name start stop [withscores] 反序由大到小的获取排名在min和max只之间的成员。  </span><br><span class="line">zremrangebyrank set-name start stop 删除有序集合中分值排序在start到stop之间的成员</span><br></pre></td></tr></table></figure>
<h4 id="基于分值的处理"><a href="#基于分值的处理" class="headerlink" title="基于分值的处理"></a>基于分值的处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore set-name min max [withscores] [limit offset count] 获取分值在min到max之间的成员。成员顺序由小到大排序。    </span><br><span class="line">zrevrangebyscore set-name max min [withscores] [limit offset count] 反序获取分值在max到min之间的成员。成员顺序由大到小排序。  </span><br><span class="line">zremrangebyscore set-name min max 删除有序集合中分值在min到max之间的成员</span><br></pre></td></tr></table></figure>
<h4 id="集合运算-1"><a href="#集合运算-1" class="headerlink" title="集合运算"></a>集合运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinterstore dest-set key-count zset-name zset-name1 [zset-name2] [weights [weigtht1 [weight2]...]] [aggregate sum|min|max] 对多个有序集合做交集运算。运算首选是取多个集合中成员的交集，成员的分数取决于aggregate参数指定的聚合函数和weight参数指定的乘法因子，aggregate默认是sum，weight默认是1。即会对相同成员的分值分别乘以集合对应的乘法因子再进行相加。其中key-count是指定参与交集运算的集合数量。  </span><br><span class="line">zunionstore dest-set key-count zset-name zset-name1 [zset-name2] [weights [weigtht1 [weight2]...]] [aggregate sum|min|max] 对多个有序集合进行并集运算。</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort src-key [by pattern] [limit offset count] [get pattern [get pattern...]] [asc|desc] [alpha] [store dest-key] 排序  </span><br><span class="line">sort 指令可以对字符串，数字，集合以及有序集合进行排序  </span><br><span class="line">sort 指令对字符串进行排序时需要指定alpha参数  </span><br><span class="line">sort 指令by pattern 中pattern都是包含一些占位符的参数如level_* *是来自于src-key中的值。这样参数level_* 对应的值则作为实际排序的权值。  </span><br><span class="line">sort 指令get pattern 中pattern都是包含一些展位费的参数如value_* *是来自于sort最终的结果。这样最终展现的结果则是pattern所对应的值。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以参考<a href="http://redisdoc.com/key/sort.html" target="_blank" rel="noopener">http://redisdoc.com/key/sort.html</a></p>
</blockquote>
<h2 id="键的生存周期"><a href="#键的生存周期" class="headerlink" title="键的生存周期"></a>键的生存周期</h2><p>Redis支持为键设置一个生存周期，一旦到达生存周期，Redis会自动删除该键。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">persist key 移除键的生存周期  </span><br><span class="line">ttl key 查看键还有多少秒的生存周期  </span><br><span class="line">expire key seconds 给键设置seconds秒的生存周期  </span><br><span class="line">expireat key time 给键设置指定的unix时间戳作为生存截至时间  </span><br><span class="line">pttl key 查看键还有多少毫秒的生存周期  </span><br><span class="line">pexpire key mil-seconds 给键设置毫秒级的生存周期  </span><br><span class="line">pexpireat key time 给键设置毫秒级的unix时间戳作为生存截至时间</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="小磊砸" />
            
              <p class="site-author-name" itemprop="name">小磊砸</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小磊砸</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://xiaoleiza.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
