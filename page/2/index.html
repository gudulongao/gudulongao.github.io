<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="小磊砸的布劳格">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="小磊砸的布劳格">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小磊砸的布劳格">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>小磊砸的布劳格</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小磊砸的布劳格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/collect-线程安全的hashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/collect-线程安全的hashmap/" itemprop="url">线程安全的HashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T23:28:24+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/collect-线程安全的hashmap/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/collect-线程安全的hashmap/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p><img src="/2018/09/05/collect-线程安全的hashmap/hashtable.png" alt="hashtable">  </p>
<p>HashTable是线程安全的map，其对所有的get/put方法都通过synchronized关键词来保证线程安全。由于关键词synchronized修饰的是方法，所以线程在执行get/put操作时都会需要获取到这个map对象锁。效率低</p>
<h1 id="Collections-synchronizedMap"><a href="#Collections-synchronizedMap" class="headerlink" title="Collections.synchronizedMap"></a>Collections.synchronizedMap</h1><p><img src="/2018/09/05/collect-线程安全的hashmap/包装.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示，通过Collections.synchronizedMap可以将hashmap包装成一个线程安全的hashmap。</p>
<p><img src="/2018/09/05/collect-线程安全的hashmap/synchronizedmap.png" alt="包装生成线程安全的hashmap"></p>
<p>对于synchronziedMap其实也是基于synchronized来保证的线程安全性，在所有的方法操作之前都需要获取mutex对象锁。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="1-7版"><a href="#1-7版" class="headerlink" title="1.7版"></a>1.7版</h2><p><img src="/2018/09/05/collect-线程安全的hashmap/concurrenthashmap.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示，concurrenthashmap主要由segemtn,entry和链表构成。concurrenthashmap本质是一个segment数组，每一个segment对应着一个Entry数组，Entry数组中的每一个Entry节点都是一个单向链表的头节点。</p>
<h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><p>Segment继承自<strong>ReentranLock</strong>。故Segment其实就是一个锁，Segment是其对应的Entry数组(table)的线程安全的保证。即每当要对Segment对应的table进行操作首先要对Segment加锁。  </p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>每一个Segment都有一个count属性，被<strong>volatile</strong>修饰的。这样每当有线程造成对table的结构性修改都会立即可见。其记录着Segment所包含的HashEntry个数，</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>每一个Segment对应着一个table，被<strong>volatile</strong>修饰。这样每当有线程造成对table的结构性修改都会立即可见。</p>
<h3 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V value;</span><br><span class="line">        final  volatile HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>
<p>HashEntry是Segment中的所有元素的抽象。其value和next都是由volatile修饰的，<strong>由于value和next都被volatile修饰，故每次线程都能读取到最新的数据，所以concurrenthashmap的读操作并没有加锁</strong>。<br>由于next被final修饰，故当有冲突时，节点都从链表的头插入，</p>
<h3 id="concurrencyLevel"><a href="#concurrencyLevel" class="headerlink" title="concurrencyLevel"></a>concurrencyLevel</h3><p>并发度就是concurrenthashmap理想可以支持并发线程数，即Segment的个数。<strong>concurrencyLevel默认是16，concurrentHashMap理想支持16个线程并发操作</strong>。</p>
<h3 id="计算key所在的Segment位置"><a href="#计算key所在的Segment位置" class="headerlink" title="计算key所在的Segment位置"></a>计算key所在的Segment位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Returns the segment that should be used for key with given hash</span><br><span class="line">  * @param hash the hash code for the key</span><br><span class="line">  * @return the segment</span><br><span class="line">  */</span><br><span class="line"> final Segment&lt;K,V&gt; segmentFor(int hash) &#123;</span><br><span class="line">     return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>方法segmentFor就是根据key的hash值来计算key所处的Segment位置，其中SegmentShift=log(size)以2为底。segmentMask=concurrencyLevel-1。</p>
<h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p><img src="/2018/09/05/collect-线程安全的hashmap/concurrencyhashmap1.8.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示。在JDK1.8版本中，对ConcurrentHashMap做了很大的调整。去除了Segment分段锁的设计。采用Node结构，结合单向链表和红黑树来解决冲突（当冲突链表中数据个数大于8个自动将链表转化成红黑树，<strong>查询效率有O(n)降低到O(logn)</strong>，当红黑树的节点个数小于6再转化成链表）。</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">   final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">   	  //参数盘空</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       //重算key的哈希值</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">       //死循环，直到成功put才会结束循环（配合CAS策略）</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">           //如果table为空，则初始化table，concurrenthashmap的构造函数并不会初始化</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">               tab = initTable();</span><br><span class="line">           //如果指定位置为空，则表明没有发生冲突，直接在table中增加节点（tabAt和casTabAt都是通过Unsafe的CAS操作）</span><br><span class="line">           else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">               if (casTabAt(tab, i, null,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                   break;                   // no lock when adding to empty bin</span><br><span class="line">           &#125;</span><br><span class="line">           //正在扩容，则帮助扩容。</span><br><span class="line">           else if ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           else &#123;</span><br><span class="line">               V oldVal = null;</span><br><span class="line">               //对指定位置的Node（头节点）加锁（注意使用的是synchronized来加锁）</span><br><span class="line">               synchronized (f) &#123;</span><br><span class="line">                   //比较头节点</span><br><span class="line">                   if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       if (fh &gt;= 0) &#123;</span><br><span class="line">                           binCount = 1;</span><br><span class="line">                           //遍历链表，找到尾部插入新节点</span><br><span class="line">                           for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               if (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   if (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               if ((e = e.next) == null) &#123;</span><br><span class="line">                                   pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, null);</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       //遍历红黑树，插入新节点</span><br><span class="line">                       else if (f instanceof TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = 2;</span><br><span class="line">                           if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != null) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               if (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               //如果链表的节点数达到需要转换成红黑树的阀值，在转换成红黑树</span><br><span class="line">               if (binCount != 0) &#123;</span><br><span class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   if (oldVal != null)</span><br><span class="line">                       return oldVal;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(1L, binCount);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过put方法的源码可以发现：  </p>
<ul>
<li>通过synchronized来对链表的头节点Node进行加锁。而没有使用1.7版本中的ReentranLock。  </li>
<li>整个concurrentHashMap的初始化是发生在第一次put的时候。  </li>
<li>指定位置节点的获取，更新以及增加的操作都是通过Unsafe利用CAS策略来实现的，这种无锁的处理方式减少了因为锁导致的线程阻塞，增大了系统的吞吐量。</li>
</ul>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        //重算key的哈希值</span><br><span class="line">        int h = spread(key.hashCode());</span><br><span class="line">        //获取指定位置的Node（无冲突时链表的头节点）判断如果一致则返回</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">            if ((eh = e.hash) == h) &#123;</span><br><span class="line">                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果是扩容，则通过ForwardingNode查找</span><br><span class="line">            else if (eh &lt; 0)</span><br><span class="line">                return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">            //依次遍历查找</span><br><span class="line">            while ((e = e.next) != null) &#123;</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过get方法的源码，可以看出,get方法并没有加锁。</p>
<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p><img src="/2018/09/05/collect-线程安全的hashmap/8-cas.png" alt="包装生成线程安全的hashmap"></p>
<p>如图中所示，在1.8版的ConcurrentHashMap中还是使用到了CAS策略，通过Unsafe来完成获取指定位置的Node，通过比较交换来设置指定位置的Node以及增加对应位置的Node。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>1.8版本的锁颗粒度更小，只是对Node数组中的Node节点通过synchronized来加锁。而1.7版本中是对整个Segment来加锁。  </li>
<li>1.8中除了通过链表来解决冲突之外，当链表中节点的个数大于8个之后会转换成红黑树，这样使得当有冲突时查找数据的效率由O(n)降低到了O(logn)。<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li>
</ul>
<blockquote>
<p> <a href="https://blog.csdn.net/justloveyou_/article/details/72783008" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/72783008</a><br> <a href="https://blog.csdn.net/bolang789/article/details/79855053" target="_blank" rel="noopener">https://blog.csdn.net/bolang789/article/details/79855053</a><br> <a href="https://blog.csdn.net/fouy_yun/article/details/77816587" target="_blank" rel="noopener">https://blog.csdn.net/fouy_yun/article/details/77816587</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/java-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/java-1/" itemprop="url">PO/BO/VO/POJO/DAO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T16:06:34+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/java-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/java-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PO-VO-BO-DAO-简介"><a href="#PO-VO-BO-DAO-简介" class="headerlink" title="PO/VO/BO/DAO 简介"></a>PO/VO/BO/DAO 简介</h1><h2 id="PO（Presistant-Object）"><a href="#PO（Presistant-Object）" class="headerlink" title="PO（Presistant Object）"></a>PO（Presistant Object）</h2><p>持久化对象，数据库中数据的抽象，即对应表中的一条记录。</p>
<h2 id="BO-Business-Object"><a href="#BO-Business-Object" class="headerlink" title="BO(Business Object)"></a>BO(Business Object)</h2><p>业务对象，可以包含多个其他对象。</p>
<blockquote>
<p>一份简历，包含教育经历，工作经历等，教育经历对应一个PO，工作经历对应一个PO，这样简历BO就由这些PO组成。</p>
</blockquote>
<h2 id="DTO-Data-Transfer-Object"><a href="#DTO-Data-Transfer-Object" class="headerlink" title="DTO(Data Transfer Object)"></a>DTO(Data Transfer Object)</h2><p>数据传输对象，用于前端与后端进行数据交互。由于涉及到网络传输，故DTO会根据展示层的要求来简化数据来减少网络流量。</p>
<blockquote>
<p>比如一个表有20个字段，对应的PO也会有20个字段，界面展现只需要展现5个字段，故只需要DTO包含界面展现的5个字段进行传输即可，相比较传输真个PO，这样减少了网络流量，也不会暴露整个表结构。</p>
</blockquote>
<h2 id="VO-Value-Object"><a href="#VO-Value-Object" class="headerlink" title="VO(Value Object)"></a>VO(Value Object)</h2><p>值对象，常用于前端组件进行数据展现的时候所使用的数据结构。其来自于DTO。</p>
<h2 id="POJO-plain-ordinary-java-object"><a href="#POJO-plain-ordinary-java-object" class="headerlink" title="POJO(plain ordinary java object)"></a>POJO(plain ordinary java object)</h2><p>简单的java对象。普通的javabean。</p>
<h1 id="区别与应用"><a href="#区别与应用" class="headerlink" title="区别与应用"></a>区别与应用</h1><h2 id="VO与DTO"><a href="#VO与DTO" class="headerlink" title="VO与DTO"></a>VO与DTO</h2><p>当展现层的需求只有一种的时候，可以使用DTO来替代VO，在设计层面，DTO只是用来明确服务端接收的请求的数据或者响应请求的数据，而界面展现的时候，特别是当展现的需求多种多样的时候，会基于同一种DTO而衍生出不同的VO。</p>
<blockquote>
<p>比方说性别，DTO中sex是男女，如果普通的展现需求，可以直接利用DTO中的sex属性来展现。但如果有个性化定制的时候，比方说需要展现成帅哥/美女，这种时候基于同样的DTO就需要根据展现的需求来衍生出性别为帅哥/美女的VO。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/collect-hashmap-hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/collect-hashmap-hashtable/" itemprop="url">HashMap与HashTable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T13:49:37+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/collect-hashmap-hashtable/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/collect-hashmap-hashtable/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HasMap"><a href="#HasMap" class="headerlink" title="HasMap"></a>HasMap</h1><ul>
<li>HashMap是基于哈希表实现的。每一个元素都是key-value的键值对。并通过链表来解决冲突问题。  </li>
<li>HashMap是非线程安全的。可以利用<strong>Collections.synchronizedMap</strong>来获取经过线程安全包装的HashMap。  </li>
<li>HashMap实现了Serializable接口，支持克隆。</li>
<li>HashMap默认大小是16（<strong>必须是2的整次幂</strong>），加载因子默认是0.75，即当已使用当前容量的0.75后，HashMap会自动扩容（2倍）。容量大小和加载因子都可以在构造的时候指定。</li>
<li>HashMap允许添加的元素key，value为空。</li>
</ul>
<h2 id="存储逻辑"><a href="#存储逻辑" class="headerlink" title="存储逻辑"></a>存储逻辑</h2><p>HashMap底层是一个Entry的数组。并利用链表来解决冲突，即没有个Entry是链表的头部节点。每一次添加一个key-value元素时，基于key的哈希值和HashMap的大小来计算出元素所位于Entry数组的位置索引（key的哈希值&amp;&amp;0x7FFFFFFF，<strong>为了去除哈希值的符号</strong>，再与size取模），如果两个元素计算出的位置索引一致，则会将元素添加到同一个entry下的链表中。<br><img src="/2018/09/05/collect-hashmap-hashtable/hashmap-struct.png" alt="HashMap存储结构"><br>如图，紫色部分是Enty数组，绿色部分时用来解决冲突的链表。</p>
<h2 id="扩容逻辑"><a href="#扩容逻辑" class="headerlink" title="扩容逻辑"></a>扩容逻辑</h2><p>当HashMap的使用空间=当前容量*加载因子后，HashMap会自动扩容，<br>扩容会新建一个Entry数组，将已有的所有元素都重新计算位置索引并转移到新的Entry数组中。所以扩容会相当的费时。  </p>
<ul>
<li>当加载因子越小，容易进行扩容操作，能使用的空间小，也会造成大量的空间浪费。  </li>
<li>当加载因子越大，不容易进行扩容操作。空间使用率高，但冲突率会加大，链表会很长，这样查询的效率会很低。  </li>
</ul>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul>
<li>HashTable是基于哈希表实现的，也是通过链表来解决冲突。</li>
<li>HashTable是线程安全的。所有操作的方法都有Synchronized关键词修饰。</li>
<li>HashTable也实现了Serizlizable接口，支持克隆。</li>
<li>HashTable默认大小11，加载因子默认也是0.75，自动扩容为（2倍+1）。容量和加载因子可以在构造时指定。</li>
<li>HashTable不允许添加的元素key为空，源码中可以看到，当key为空时，会抛出空指针异常。<br><img src="/2018/09/05/collect-hashmap-hashtable/hashtablecode.png" alt="HashTable源码"></li>
</ul>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="继承父类不同"><a href="#继承父类不同" class="headerlink" title="继承父类不同"></a>继承父类不同</h2><p>HashMap继承自AbstractMap，HashTable继承自Dictionary。但都实现了Map接口。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>HashMap不是线程安全的，而HashTable是线程安全的。</p>
<h2 id="是否提供contains方法"><a href="#是否提供contains方法" class="headerlink" title="是否提供contains方法"></a>是否提供contains方法</h2><p>HashMap提供containsKey和containsValue两个方法，HashTable提供contains,containsKey和containsValue三个方法（containsValue中调用的contains方法）。</p>
<h2 id="key是否允许为null"><a href="#key是否允许为null" class="headerlink" title="key是否允许为null"></a>key是否允许为null</h2><p>HashMap允许key和value为null,HashTable不允许key和value为空。<strong>因此在HashMap中不能通过get方法来判断是否存在某一个key，有可能这个key就是null</strong></p>
<h2 id="哈希值的不同"><a href="#哈希值的不同" class="headerlink" title="哈希值的不同"></a>哈希值的不同</h2><p>HashMap是重新计算key的哈希值，在与0x7FFFFFFF做与运算，去除符号后与size取模来计算元素在Entry数组中的位置索引。HashTable是直接利用key的哈希值来与size取模获取位置索引。</p>
<h2 id="扩容逻辑不同"><a href="#扩容逻辑不同" class="headerlink" title="扩容逻辑不同"></a>扩容逻辑不同</h2><ul>
<li>HashMap默认大小16，HashTable默认大小11.</li>
<li>HashMap每次扩容为原有的2倍，HashTable扩容为原有的2倍+1。  </li>
<li>HashMap要求Entry数组长度必须是2的整次幂，HashTable没有要求。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/http-state-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/http-state-code/" itemprop="url">http状态码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T23:18:03+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/04/http-state-code/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/04/http-state-code/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面试的时候被问到了有关状态码的内容，现整理如下表所示：</p>
<h1 id="正在执行"><a href="#正在执行" class="headerlink" title="正在执行"></a>正在执行</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>正在执行</td>
</tr>
</tbody>
</table>
<h1 id="成功处理请求"><a href="#成功处理请求" class="headerlink" title="成功处理请求"></a>成功处理请求</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td><strong>成功返回</strong></td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>资源已依据请求创建</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td><strong>已接收请求但并未处理，异步执行，可能执行了可能没执行</strong></td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>已处理请求，但返回数据的来源非原始服务器，可能来自本地或第三方的拷贝。即<strong>非授权信息</strong></td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>处理请求后无返回数据</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>处理请求后无返回，但需要请求方需要重置文档视图（浏览器需要重置表单）</td>
</tr>
</tbody>
</table>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>被请求的资源有多个备选的操作供请求者选择，每一个操作都对应一个地址来重定向</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>被请求的资源已被永久的变更到新地址，<strong>使用get请求时会自动重定向</strong></td>
</tr>
<tr>
<td>302</td>
<td>Move temporarily</td>
<td>被请求的资源临时从别的地址来响应，请求者还是通过原有地址来请求</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>请求的资源可以在另一个URI中获取，请求者应该通过一个专门的get请求来获取响应</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>本次请求与上一次的请求，请求的网页没有变化，返回此状态码而不会返回网页数据</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>请求的资源必须通过指定的代理才可以被访问</td>
</tr>
<tr>
<td>306</td>
<td>Temporary Redirect</td>
<td>服务器临时从别的地址来响应请求，请求者还是通过原有地址来请求</td>
</tr>
</tbody>
</table>
<h1 id="请求错误"><a href="#请求错误" class="headerlink" title="请求错误"></a>请求错误</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>Bad Request</td>
<td><strong>请求参数错误/语义错误</strong></td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>需要认证</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>拒绝该请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>未找到指定的资源</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>拒绝请求的方法</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>无法使用请求的内容特性响应请求的网页</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>与401类似，但是需要在代理服务器进行身份认证</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>请求超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器在处理请求时发生冲突，需要返回详细的信息告知请求方冲突的来源</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>请求的资源已永久的不可用（已删除）</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>需要定义content length，即服务器拒绝没有定义有效长度的请求</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>未满足先决条件</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>请求的实体数据太大</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Long</td>
<td>请求的URI超长</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器不支持请求的数据格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable</td>
<td>请求中包含Range,但返回的数据中不符合在范围内</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>请求中包含Except，但服务器无法满足预期</td>
</tr>
<tr>
<td>421</td>
<td>too many connections</td>
<td>服务器的连接数超限</td>
</tr>
<tr>
<td>422</td>
<td>Unprocessable Entity</td>
<td>请求格式正确但含有语义错误</td>
</tr>
<tr>
<td>423</td>
<td>Locked</td>
<td>请求资源被锁定</td>
</tr>
<tr>
<td>424</td>
<td>Failed Dependency</td>
<td>由于之前的请求导致本次请求失败</td>
</tr>
<tr>
<td>451</td>
<td>Unavailable For Legal Reasons</td>
<td>请求因法律原因而不可用</td>
</tr>
</tbody>
</table>
<h1 id="服务器错误"><a href="#服务器错误" class="headerlink" title="服务器错误"></a>服务器错误</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td><strong>服务器端发生异常</strong></td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持该功能，无法识别该请求或者不能支持该请求的资源</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td><strong>网关或者代理服务器在处理请求时，无法从上游服务器获取响应</strong></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td><strong>服务器维护或者过载导致无法处理请求</strong></td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td><strong>网关或代理服务器处理请求时，获取上游服务器响应超时</strong></td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器不支持请求指定的http版本</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/redis-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis-3/" itemprop="url">redis持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T22:16:00+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/redis-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/redis-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis持久化方式"><a href="#Redis持久化方式" class="headerlink" title="Redis持久化方式"></a>Redis持久化方式</h2><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>将某个时刻的数据持久化到硬盘中。用户可以对快照进行备份。支持复制到其他服务器。</p>
<h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><ul>
<li><strong>bgsave</strong> 创建一个快照。<strong>Redis会创建一个子进程来负责将快照写入硬盘。父进程继续接受请求。</strong></li>
<li><strong>save</strong> Redis在快照创建完毕前不会接受任何请求。</li>
<li><strong>shutdown</strong>命令用于停止redis服务的时候会执行一次<strong>save</strong>命令。停止所有请求。</li>
<li><strong>sync</strong>命令进行Redis服务器之间的数据同步的时候。如果主服务器并没有正在进行bgsave或者不是刚刚结束bgsave命令时会执行bgsave命令。</li>
</ul>
<h4 id="快照配置"><a href="#快照配置" class="headerlink" title="快照配置"></a>快照配置</h4><blockquote>
<p>save 60 1000    60秒内有1000次写操作则自动触发bgsave<br>stop-writes-on-bgsave-error-no  当创建快照失败时是否停止写操作<br>rdbcompression yes  是否对快照进行压缩<br>dbfilename dump.rdb 快照名称<br>dr ./   快照文件存储的路径</p>
</blockquote>
<h4 id="快照缺陷"><a href="#快照缺陷" class="headerlink" title="快照缺陷"></a>快照缺陷</h4><ul>
<li>快照是某一个时间点的内存数据备份。如果在服务器崩溃则会丢失上一次快照到崩溃时的所有变更数据。   </li>
<li>快照适合即使丢失一部分少量的数据也不会对整个应用造成问题的场景。   </li>
</ul>
<blockquote>
<p>《Redis实战》中提到的对日志进行聚合计算。没有看懂到底是什么意思。   </p>
</blockquote>
<ul>
<li>当大数据处理时，Redis占用的内存会很大，bgsave创建子进程会耗费一定的时间，这个创建的过程则会导致redis停顿。停顿的时间随着Redis占用内存越大而越久。相比较于创建子进程带来的停顿，save并不会因为要创建子进程而去争抢资源导致停顿。故save会较bgsave的速度更快。</li>
</ul>
<h3 id="AOF-append-only-file"><a href="#AOF-append-only-file" class="headerlink" title="AOF(append-only file)"></a>AOF(append-only file)</h3><p>将写操作的命令追加到备份文件中。等到需要恢复时（重启）从头到尾执行一遍备份文件中的写命令即可。</p>
<h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>随着Redis不断的运行。aof文件会变得越来越大。占用硬盘同时在重启时根据aof重新执行写命令时耗时长。<br><strong>bgrewriteaof</strong> 等同bgsave，会启动子进程来重写aof文件。父进程继续接受请求。</p>
<h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><blockquote>
<p>appendonly yes  是否启用AOF模式<br>appendfsync everrysec 追加的频率。always每次写操作都同步。everysec每秒执行一次同步，可以同步多条写操作。no 由操作系统来决定何时进行同步。<br>no-appendfsync-on-rewrite no<br>auto-aof-rewrite-percentage 100 当aof文件比上一次重写时大了一倍则进行aof文件重写<br>auto-aof-rewrite-min-size 64mb  当aof文件的大小大于64mb时进行aof文件重写<br>dr ./   aof文件存储路径     </p>
</blockquote>
<h4 id="AOF缺陷"><a href="#AOF缺陷" class="headerlink" title="AOF缺陷"></a>AOF缺陷</h4><ul>
<li><strong>bgrewriteaof</strong>命令创建子进程也会由于redis占用的内存越大而创建子进程的时间越长从而导致redis停顿。</li>
<li>对aof文件进行重写时会涉及对旧的aof文件进行删除，如果文件很大很有可能导致操作系统的挂起。</li>
</ul>
<h2 id="持久化的意义"><a href="#持久化的意义" class="headerlink" title="持久化的意义"></a>持久化的意义</h2><ul>
<li>数据重用。redis中很多的数据都是一些经过长时间计算得到的。这样持久化到硬盘中就不必再次计算可以方便下次使用。</li>
<li>安全。将数据备份到硬盘防止因系统崩溃而丢失数据。Redis运行时数据都是存储在内存中，而一旦系统奔溃内存中的数据时很大程度会丢失。  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/redis-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis-2/" itemprop="url">redis笔记二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T22:11:37+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/redis-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/redis-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅/发布模式"></a>订阅/发布模式</h2><blockquote>
<p>一般来说，发布于订阅的特点是订阅者(listener)负责订阅频道(channel)，发送者(publisher)负责向频道发送而今这字符串消息(binary string message)。每当有消息被发送至给定的频道时，频道的所有订阅者都会受到消息。<br>by 《Redis 实战》</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel1 ...] 订阅频道  </span><br><span class="line">unsubscribe [channel [channel1 ...]] 退订频道，**如果未指定channel则默认退订所有频道。**  </span><br><span class="line">publish channel message 向频道channel发送消息  </span><br><span class="line">psubscribe pattern [pattern...] 订阅符合条件的频道  </span><br><span class="line">punsubscribe [pattern [pattern...]] 退订符合条件的频道，**如果没有指定pattern则默认退订所有频道。**</span><br></pre></td></tr></table></figure>
<h3 id="订阅-发布模式的缺陷"><a href="#订阅-发布模式的缺陷" class="headerlink" title="订阅/发布模式的缺陷"></a>订阅/发布模式的缺陷</h3><ul>
<li>系统的缺陷。旧版本的Redis。当订阅的频道消息量很大而自身的读取速度不够时会导致Redis缓冲区体积很大，这样会使得效率很低甚至崩溃。还会被操作系统强杀。新版本的Redis不会有这种问题，需要配置client-output-buffer-limit pubsub来自动断开。  </li>
<li>数据传输的可靠性。在客户端订阅过程中断线，客户端会丢失在断线期间频道的所有消息。</li>
</ul>
<h2 id="事务基本用法"><a href="#事务基本用法" class="headerlink" title="事务基本用法"></a>事务基本用法</h2><blockquote>
<p>Redis有5个命令可以让用户再不被打断的情况下对多个键执行操作，分别是watch、multi、exec、unwatch和discard。<br>Redis基本的事务用法置灰用到multi和exec命令。<br>Redis里执行事务，首先需要执行Multi命令，然后输入那些想要在事务里执行的命令，最后再执行exec命令。当</p>
</blockquote>
<p>Redis从一个客户端那里接收到multi命令时，Redis会将这个客户端之后发送的所有命令都放入到一个队列里，直到这个客户端发送exec命令为止，然后Redis就会在不被打断的情况下，一个接一个地执行存储在队列里地命令。这种事务的执行方式是通过延迟执行事务极大降低了客户端与服务端的通信连接次数来提高性能。是一种<strong>流水线事务。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi 申明后面地指令操作都在同一个事务中。    </span><br><span class="line">exec 申明事务截至，以上地所有操作都在同一个事务中。  </span><br><span class="line">watch 对键进行监控。直到exec命令之间如果有别的连接对受监控的键进行了修改，删除等更新操作，exec命令执行失败并返回错误。  </span><br><span class="line">unwatch 取消对键的监控。在执行multi之前都有效。  </span><br><span class="line">discard	取消对键的监控。在执行exec之前都有效。</span><br></pre></td></tr></table></figure>
<h3 id="Redis没有加锁"><a href="#Redis没有加锁" class="headerlink" title="Redis没有加锁"></a>Redis没有加锁</h3><p>传统数据库会在对数据库进行写操作时对访问的数据进行加锁。直到事务被提交或者回滚。其它客户端对数据进行写入时由于无法拿到数据的锁而阻塞。只有当持有锁的事务执行完毕后释放锁才可以重新执行。这种锁的缺陷是当锁的持有事务执行的时间越久，则其它事务阻塞的时间就越久<strong>（悲观锁）</strong>。<br>Redis为了尽可能的减少客户端阻塞的时间，只有当数据已经抢先被修改更新了，如果有客户段对该数据进行监控(watch)的会进行通知<strong>（乐观锁）</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/redis-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis-1/" itemprop="url">redis笔记一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T22:00:58+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/redis-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/redis-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于之前有匆忙的接触过Redis。有感受到Redis相较于关系型数据库的便捷，快速和高效。便抽空专门边学习边写一些笔记来做一些分享。学习的途径主要是参考书籍《Redis实战》，参考网站 <a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">http://redisdoc.com/index.html</a>  </p>
<blockquote>
<p>Redis是一种NoSQL数据库。可以存储key以及5种数据结构的映射。同时支持将存储在内存中的数据持久化到硬盘中（参考）。<br>by《Redis实战》</p>
</blockquote>
<p>Redis说白了就是一种key-value的数据库。数据由于存储在内存当中有很高的读写性能。其中这种基于key-value的存储结构无须为了考虑表结构而改变数据的结构是相当人性化的。<strong>Redis支持的key是字符串。对于value有String（字符串）、List（列表）、Set（集合）、ZSet（有序集合）和Hash（哈希）总共5种数据接口。</strong></p>
<h2 id="指令操作"><a href="#指令操作" class="headerlink" title="指令操作"></a>指令操作</h2><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value 	设置指定的键和值  </span><br><span class="line">get key 		获取指定的键值  </span><br><span class="line">del key			删除指定的键</span><br></pre></td></tr></table></figure>
<h4 id="自增和自减运算"><a href="#自增和自减运算" class="headerlink" title="自增和自减运算"></a>自增和自减运算</h4><blockquote>
<p>在Redis中字符串可以存储三种数据  </p>
<ol>
<li>字符串  </li>
<li>整数  </li>
<li>浮点型<br>by 《Redis实战》  </li>
</ol>
</blockquote>
<p><strong>redis支持对字符串进行自增和自减的处理。会自动将字符串进行转换成整型或者浮点型。如果不能进行转换则会返回错误码。如果处理的key并不存在则会默认从0开始走自增和自减处理</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">incr key 对key进行自增  </span><br><span class="line">decr key 对key进行自减  </span><br><span class="line">incrby key value1 对key的value自增value1  </span><br><span class="line">decrby key value2 对key的value自减value2  </span><br><span class="line">incrbyfloat key value3 对key的value自增value3(value3是浮点型数据)。</span><br></pre></td></tr></table></figure>
<p><strong>并没有decrbyfloat命令。</strong></p>
<h4 id="部分读写"><a href="#部分读写" class="headerlink" title="部分读写"></a>部分读写</h4><p>Redis还支持对字符串部分内容进行读写的操作，<strong>这种操作是支持对整型和浮点型数据处理，但不建议这样做。</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">append key value1 向字符串key的value追加value1  </span><br><span class="line">getrange key start end 获取字符串key的value从start到end部分的值（包括start和end位置）  </span><br><span class="line">setrange key offset value1 从offset开始将字符串key的value替换成value1。value1的长度必须小于value从offset开始的长度。</span><br></pre></td></tr></table></figure>
<p><strong>当value的长度不足时会自动将长度增加到符合条件时。即这条指令有追加的功能。</strong> </p>
<h4 id="二进制处理"><a href="#二进制处理" class="headerlink" title="二进制处理"></a>二进制处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset 将字符串作为二进制字符串。获取offset位置二进制的值  </span><br><span class="line">setbit key offset value1 设置二进制字符串key的value中offset位置的二进制值为value1  </span><br><span class="line">bitcount key [start] [end] 统计字符串key的value中二进制位为1的数量。start和end可选  </span><br><span class="line">bitop operator key1 key2 [key3...] destkey 对多个key的value进行二进制运算，运算结果存储在destkey中。运算类型支持并(and)、或（or）、异或（xor）和非（not）。</span><br></pre></td></tr></table></figure>
<h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><p>列表中可以存储多个字符串。同时可以重复。  </p>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lpush key [key1...] 向key的列表左端添加多个字符串。rpush是从右端添加字符串  </span><br><span class="line">lpop key 从key的列表左端删除一个字符串。rpop是从右端删除字符串    </span><br><span class="line">lindex key index 获取key的列表中index位置的字符串  </span><br><span class="line">lrange key start end 获取指定范围列表中的字符串。start=0,end=-1时可以获取列表所有的字符串  </span><br><span class="line">ltrim key start end 保留key的列表从start到end位置的字符串。</span><br></pre></td></tr></table></figure>
<h4 id="列表转移"><a href="#列表转移" class="headerlink" title="列表转移"></a>列表转移</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpoplpush src-list dest-list 从src-list的右端弹出一个元素插入到dest-list的左端。</span><br></pre></td></tr></table></figure>
<p><strong>没有lpoprpush命令</strong>  </p>
<h4 id="阻塞队列操作"><a href="#阻塞队列操作" class="headerlink" title="阻塞队列操作"></a>阻塞队列操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blpop list [list-1 ...] timeout 可以对多个list进行左弹出一个字符串。但是会从左到右处理第一个非空列表。timeout是指当列表为空时会阻塞的时间。  </span><br><span class="line">brpop 同blpop。只是从列表的右端弹出字符串。  </span><br><span class="line">brpoplpush src-list dest-list timeout 从src-list中最右端弹出一个元素添加到dest-list的左端。如果src-list为空则阻塞timeout时长。</span><br></pre></td></tr></table></figure>
<p>对于阻塞队列的操作常用于<strong>消息的传递和任务队列</strong>。</p>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><blockquote>
<p>集合是通过散列的表来保证元素都是不相同的（这些散列表只有键，没有与键对应的值）。<br>by 《Redis 实战》</p>
</blockquote>
<h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sadd set-name item [item-1] 向集合添加元素。支持同时加入多个元素</span><br><span class="line">smembers set-name 获取集合的所有元素。**当集合元素很多时效率很低，谨慎使用**  </span><br><span class="line">sismember set-name item 判断元素是否时集合中的元素</span><br><span class="line">srem set-name item [item-1] 从集合中删除元素。支持同时删除多个元素  </span><br><span class="line">scard set-name 获取集合元素的个数</span><br><span class="line">srandmember set-name [count] 随机返回集合中的元素。count&gt;0时返回的元素不重复。count&lt;0时返回的元素会重复。</span><br><span class="line">spop 随机从元素中删除一个元素</span><br><span class="line">smove src-set dest-set item 如果src-set中包含元素item则从src-set中删除，在dest-set中加入该元素。</span><br></pre></td></tr></table></figure>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sdiff set-name set-name2 [set-name3...] 多个集合的差集  </span><br><span class="line">sdiffstore dest-set set-name set-name2 [set-name3...] 将多个集合的差集存储到dest-set中  </span><br><span class="line">sinner set-name set-name2 [set-name3...] 多个集合的交集  </span><br><span class="line">sinnerstore dest-set set-name set-name2 [set-name3...] 将多个集合的交集存储到dest-set中  </span><br><span class="line">sunion set-name set-name2 [set-name3...] 多个集合的并集</span><br><span class="line">sunionstore dest-set set-name set-name2 [set-name3...] 将多个集合的并集存储到dest-set中</span><br></pre></td></tr></table></figure>
<h3 id="散列操作"><a href="#散列操作" class="headerlink" title="散列操作"></a>散列操作</h3><p>散列可以存储多个键值对。键值对的值同字符串一样，可以是字符串也可以是数字值。同时支持对散列存储的值进行自增处理。</p>
<blockquote>
<p>散列在很多方面就像是一个微缩版的Redis<br>by 《Redis 实战》</p>
</blockquote>
<h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hset map-name key value 向散列map-name中存放键值对key value。  </span><br><span class="line">hget map-name key 获取散列map-name中键key对应的value  </span><br><span class="line">hget map-name 获取散列map-name所有的键值对  </span><br><span class="line">hdel map-name key [key1...] 删除散列map-name中的键key。支持同时删除多个key</span><br><span class="line">hlen map-name 获取散列map-name中键值对的数量  </span><br><span class="line">hexists map-name key 判断散列map-name中是否包含key</span><br></pre></td></tr></table></figure>
<h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><blockquote>
<p>批量处理多个键的命令既可以给用户带来方便，又可以通过减少命令的调用次数以及客户端与redis之间的通讯往返次数来提升redis的性能。<br>by 《Redis 实战》</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hmset map-name key value [key1 value1 ...] 同时向散列map-name中存储多个键值对  </span><br><span class="line">hmget map-name key [key1...] 获取散列map-name中多个key的值  </span><br><span class="line">hkeys map-name 获取散列所有的键  </span><br><span class="line">hvals map-name 获取散列所有的值  </span><br><span class="line">hgetall map-name 获取散列所有的键值对</span><br></pre></td></tr></table></figure>
<h4 id="自增处理"><a href="#自增处理" class="headerlink" title="自增处理"></a>自增处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby map-name key increament 对散列map-name的key对应的值自增increament  </span><br><span class="line">hincrbyfloat map-name key increament 对散列map-name的key对应的值自增increament(浮点型)</span><br></pre></td></tr></table></figure>
<p><strong>对于散列中未存在的key进行自增处理时同样会将value初始作为0开始运算。</strong></p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><blockquote>
<p>有序集合和散列一样，都用于存储键值对:有序集合的键成为成员，每个成员都是各不相同的；而有序集合的值则 被称为分值，分值必须浮点型。<br>有序集合既可以根据成员访问元素，又可以根据分值以及分值的排列顺序来访问元素。<br>by 《Redis实战》</p>
</blockquote>
<h4 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zadd set-name score item [score item ...] 向有序集合添加分值score的成员item  </span><br><span class="line">zrem set-name item [item1...] 删除有序集合中的元素  </span><br><span class="line">zcard set-name 有序集合的成员个数  </span><br><span class="line">zcount set-name min max 获取有序集合分值介于min和max之间的成员</span><br><span class="line">zrank set-name item 获取成员的排名</span><br><span class="line">zrevrank set-name item 获取成员的排名（反序，分值由大到小）</span><br><span class="line">zscore set-name item 获取成员的分值</span><br><span class="line">zincrby set-name item increament 给成员的分值增加increament</span><br></pre></td></tr></table></figure>
<h4 id="基于分值的排名"><a href="#基于分值的排名" class="headerlink" title="基于分值的排名"></a>基于分值的排名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrange set-name start stop [withscores] 获取分值排名在start和stop之间的成员。withscores是返回时带有分值。  </span><br><span class="line">zrevrange set-name start stop [withscores] 反序由大到小的获取排名在min和max只之间的成员。  </span><br><span class="line">zremrangebyrank set-name start stop 删除有序集合中分值排序在start到stop之间的成员</span><br></pre></td></tr></table></figure>
<h4 id="基于分值的处理"><a href="#基于分值的处理" class="headerlink" title="基于分值的处理"></a>基于分值的处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore set-name min max [withscores] [limit offset count] 获取分值在min到max之间的成员。成员顺序由小到大排序。    </span><br><span class="line">zrevrangebyscore set-name max min [withscores] [limit offset count] 反序获取分值在max到min之间的成员。成员顺序由大到小排序。  </span><br><span class="line">zremrangebyscore set-name min max 删除有序集合中分值在min到max之间的成员</span><br></pre></td></tr></table></figure>
<h4 id="集合运算-1"><a href="#集合运算-1" class="headerlink" title="集合运算"></a>集合运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinterstore dest-set key-count zset-name zset-name1 [zset-name2] [weights [weigtht1 [weight2]...]] [aggregate sum|min|max] 对多个有序集合做交集运算。运算首选是取多个集合中成员的交集，成员的分数取决于aggregate参数指定的聚合函数和weight参数指定的乘法因子，aggregate默认是sum，weight默认是1。即会对相同成员的分值分别乘以集合对应的乘法因子再进行相加。其中key-count是指定参与交集运算的集合数量。  </span><br><span class="line">zunionstore dest-set key-count zset-name zset-name1 [zset-name2] [weights [weigtht1 [weight2]...]] [aggregate sum|min|max] 对多个有序集合进行并集运算。</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort src-key [by pattern] [limit offset count] [get pattern [get pattern...]] [asc|desc] [alpha] [store dest-key] 排序  </span><br><span class="line">sort 指令可以对字符串，数字，集合以及有序集合进行排序  </span><br><span class="line">sort 指令对字符串进行排序时需要指定alpha参数  </span><br><span class="line">sort 指令by pattern 中pattern都是包含一些占位符的参数如level_* *是来自于src-key中的值。这样参数level_* 对应的值则作为实际排序的权值。  </span><br><span class="line">sort 指令get pattern 中pattern都是包含一些展位费的参数如value_* *是来自于sort最终的结果。这样最终展现的结果则是pattern所对应的值。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以参考<a href="http://redisdoc.com/key/sort.html" target="_blank" rel="noopener">http://redisdoc.com/key/sort.html</a></p>
</blockquote>
<h2 id="键的生存周期"><a href="#键的生存周期" class="headerlink" title="键的生存周期"></a>键的生存周期</h2><p>Redis支持为键设置一个生存周期，一旦到达生存周期，Redis会自动删除该键。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">persist key 移除键的生存周期  </span><br><span class="line">ttl key 查看键还有多少秒的生存周期  </span><br><span class="line">expire key seconds 给键设置seconds秒的生存周期  </span><br><span class="line">expireat key time 给键设置指定的unix时间戳作为生存截至时间  </span><br><span class="line">pttl key 查看键还有多少毫秒的生存周期  </span><br><span class="line">pexpire key mil-seconds 给键设置毫秒级的生存周期  </span><br><span class="line">pexpireat key time 给键设置毫秒级的unix时间戳作为生存截至时间</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/24/picture-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/24/picture-test/" itemprop="url">picture test</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-24T15:55:34+08:00">
                2018-08-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/24/picture-test/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/08/24/picture-test/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2018/08/24/picture-test/test.png" alt="abc"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/SpringBoot-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/SpringBoot-1/" itemprop="url">SpringBoot学习笔记一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T22:50:41+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/23/SpringBoot-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/08/23/SpringBoot-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="bean的生命周期（Scope）"><a href="#bean的生命周期（Scope）" class="headerlink" title="bean的生命周期（Scope）"></a>bean的生命周期（Scope）</h2><p>Spring中bean的生命周期可以通过注解@Scope来声明配置，其中注解Scope支持的生命周期如下表所示。  </p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Singleton</td>
<td>单例，默认配置</td>
</tr>
<tr>
<td>Peororype</td>
<td>每次调用都会构建</td>
</tr>
<tr>
<td>Request</td>
<td>Web项目中每一次http request新建</td>
</tr>
<tr>
<td>Session</td>
<td>Web项目中每一个http session新建</td>
</tr>
</tbody>
</table>
<h2 id="bean的创建和销毁"><a href="#bean的创建和销毁" class="headerlink" title="bean的创建和销毁"></a>bean的创建和销毁</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Bean注解的initMethod属性</td>
<td>通过在配置类中声明bean的时候显示的指定该bean的初始化逻辑</td>
</tr>
<tr>
<td>@Bean注解的destoryMethod属性</td>
<td>通过在配置类中声明bean的时候显示的指定该bean的销毁逻辑</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>JSR-250提供，用于声明于方法体，表明该方法将在构造函数之后调用</td>
</tr>
<tr>
<td>@PreDestory</td>
<td>JSR-250提供，用于声明于方法体，表明该方法将在对象回收之前调用</td>
</tr>
</tbody>
</table>
<h2 id="加载配置文件"><a href="#加载配置文件" class="headerlink" title="加载配置文件"></a>加载配置文件</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@PropertySource</td>
<td>指定待加载配置文件的路径，通常用于配置类</td>
</tr>
<tr>
<td>@Value</td>
<td>通过注入的属性来匹配配置文件中的配置，常用于字段,即将配置文件中对应配置的值注入到当前字段</td>
</tr>
</tbody>
</table>
<p>对于@Value注解，如果当前配置类中有使用注解@ProppertySource,则表明该注解匹配的配置文件是注解中指定的配置文件，否则就是加载的PeopertySourcesPlaceholderConfigurer中配置的配置文件。  </p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>注解@PropertySource是否支持加载yml配置？</p>
<blockquote>
<p>正如注解的的名称，PropertySource只能加载properties配置文件，对于yml的配置，可以通过注解@ConfigurationProperties来加载。</p>
</blockquote>
<h3 id="Value注解使用样例"><a href="#Value注解使用样例" class="headerlink" title="Value注解使用样例"></a>Value注解使用样例</h3><ul>
<li>1.对于@Value注解只能用于实体属性，用于给当前实体属性注入值，值取决于注解的用法，可以匹配配置文件中的配置属性值，也可以是系统环境变量，字符串等。  </li>
<li>2.在使用@Value注解来匹配配置文件中的属性值的时候，必须在当前的配置类中构建或者声明一个PropertySourcesPlaceholderConfigurer的bean。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package demo.base;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.io.IOUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.*;</span><br><span class="line">import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;</span><br><span class="line">import org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注解@Value样例</span><br><span class="line"> * @author gudulongao</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;demo.base&quot;)</span><br><span class="line">@PropertySource(&quot;valuedemo.properties&quot;)</span><br><span class="line">public class ValueAnnDemo &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载配置文件中配置</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;demo.name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;demo.age&#125;&quot;)</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自定义注入</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;abc&quot;)</span><br><span class="line">    private String str;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取系统参数</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;#&#123;systemProperties[&apos;os.name&apos;]&#125;&quot;)</span><br><span class="line">    private String osName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注入网络资源</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;http://www.baidu.com&quot;)</span><br><span class="line">    private Resource resource;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注入文件</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;classpath:valuedemo.properties&quot;)</span><br><span class="line">    private Resource file;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果使用value注解加载配置文件内容，必须要有该bean</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public static PropertySourcesPlaceholderConfigurer propertyConfigure()&#123;</span><br><span class="line">        return new PropertySourcesPlaceholderConfigurer();</span><br><span class="line">    &#125;                                                 </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ValueAnnDemo.class);</span><br><span class="line">        ValueAnnDemo demo = context.getBean(ValueAnnDemo.class);</span><br><span class="line">        System.out.println(demo.name);</span><br><span class="line">        System.out.println(demo.str);</span><br><span class="line">        System.out.println(demo.age);</span><br><span class="line">        System.out.println(demo.osName);</span><br><span class="line">        System.out.println(demo.resource);</span><br><span class="line">        System.out.println(IOUtils.toString(demo.file.getInputStream()));</span><br><span class="line">        //关闭</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下图<br><img src="/2018/08/23/SpringBoot-1/valuedemo.png" alt="abc"></p>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>Spring支持对于不同的环境能够使得不同的配置生效。例如开发环境与生产环境的配置不一样，需要按照不同的环境来使得对应的配置生效。<br>当前环境的状态标志可以通过已下方式：</p>
<ul>
<li>1.启动项目的时候通过配置jvm参数：spring.profile.active来指定当前环境的状态。  </li>
<li>2.Servlet的context parameter中指定spring.profile.active参数。    </li>
</ul>
<h3 id="Profile样例"><a href="#Profile样例" class="headerlink" title="Profile样例"></a>Profile样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package demo.base.bean;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抽象基类</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseBean &#123;</span><br><span class="line">    public abstract void hello();</span><br><span class="line">&#125;</span><br><span class="line">package demo.base.bean;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 开发bean</span><br><span class="line"> */</span><br><span class="line">public class DevBean extends BaseBean&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;dev hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package demo.base.bean;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 正式bean</span><br><span class="line"> */</span><br><span class="line">public class ProBean extends BaseBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;pro hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package demo.base;</span><br><span class="line"></span><br><span class="line">import demo.base.bean.BaseBean;</span><br><span class="line">import demo.base.bean.DevBean;</span><br><span class="line">import demo.base.bean.ProBean;</span><br><span class="line">import org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;demo.base&quot;)</span><br><span class="line">public class ProfileDemo &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&quot;dev&quot;)</span><br><span class="line">    public BaseBean getDevBean()&#123;</span><br><span class="line">        return new DevBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&quot;pro&quot;)</span><br><span class="line">    public BaseBean getProBean()&#123;</span><br><span class="line">        return new ProBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //构建注解上下文的时候没有注入配置类</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();</span><br><span class="line">        //注入环境的profile 注入profile之后再注入配置类，否则会报类未定义</span><br><span class="line">        context.getEnvironment().setActiveProfiles(&quot;pro&quot;);</span><br><span class="line">        //注册配置类</span><br><span class="line">        context.register(ProfileDemo.class);</span><br><span class="line">        //刷新</span><br><span class="line">        context.refresh();</span><br><span class="line">        //获取bean</span><br><span class="line">        BaseBean bean = context.getBean(BaseBean.class);</span><br><span class="line">        bean.hello();</span><br><span class="line">        //关闭上下文</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下图<br><img src="/2018/08/23/SpringBoot-1/profiledemo.png" alt="abc"></p>
<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>Spring提供了一套事件机制，可以使得容器中的bean之间能够互相通信，达到异步处理的效果。  </p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Event</td>
<td>事件，继承ApplicationEvent，bean与bean之间沟通的内容</td>
</tr>
<tr>
<td>Listener</td>
<td>监听器，实现ApplicationListener&lt;?&gt;，监听某一个事件，即事件的消费者，当监听的事件产生后会出发onApplicationEvent方法</td>
</tr>
<tr>
<td>Publisher</td>
<td>事件发布器，即事件的生产者，依托于ApplicationContext来发布事件</td>
</tr>
</tbody>
</table>
<h3 id="事件机制样例"><a href="#事件机制样例" class="headerlink" title="事件机制样例"></a>事件机制样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package demo.base.event;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义事件</span><br><span class="line"> *</span><br><span class="line"> * @author gudulongao</span><br><span class="line"> */</span><br><span class="line">public class DemoEvent extends ApplicationEvent &#123;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public DemoEvent(Object source, String msg) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package demo.base.event;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义监听器</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class DemoListener implements ApplicationListener&lt;DemoEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(DemoEvent demoEvent) &#123;</span><br><span class="line">        System.out.println(&quot;i accept a msg from &quot; + demoEvent.getClass().getSimpleName() + &quot;,msg: &quot; + demoEvent.getMsg() + &quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package demo.base.event;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义事件发布器</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class DemoPublish &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布事件</span><br><span class="line">     * @param msg</span><br><span class="line">     */</span><br><span class="line">    public void publish(String msg) &#123;</span><br><span class="line">        context.publishEvent(new DemoEvent(this, msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package demo.base;</span><br><span class="line"></span><br><span class="line">import demo.base.event.DemoPublish;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;demo.base&quot;)</span><br><span class="line">public class EventDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(EventDemo.class);</span><br><span class="line">        DemoPublish publish = context.getBean(DemoPublish.class);</span><br><span class="line">        publish.publish(&quot;hello&quot;);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下图所示<br><img src="/2018/08/23/SpringBoot-1/eventdemo.png" alt="abc"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/git操作笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/git操作笔记/" itemprop="url">git操作笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T10:56:55+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/23/git操作笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/08/23/git操作笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="生成ssh密钥。"><a href="#生成ssh密钥。" class="headerlink" title="生成ssh密钥。"></a>生成ssh密钥。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &apos;XXX@XXX&apos;</span><br></pre></td></tr></table></figure>
<h3 id="指定ssh公钥"><a href="#指定ssh公钥" class="headerlink" title="指定ssh公钥"></a>指定ssh公钥</h3><p>当计算机中配置多个git账号，同时git都需要基于ssh key来进行操作的时候，需要使用到如下指令来显示的指定当前操作所使用的ssh key公钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-gaent bash	</span><br><span class="line">ssh-agent -s	</span><br><span class="line">ssh-add ~/.ss/id* 使用指定的sshkey公钥</span><br></pre></td></tr></table></figure>
<h3 id="指定远程仓库"><a href="#指定远程仓库" class="headerlink" title="指定远程仓库"></a>指定远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:XXX/YYY</span><br></pre></td></tr></table></figure>
<h3 id="解决gerrit仓库pull报错"><a href="#解决gerrit仓库pull报错" class="headerlink" title="解决gerrit仓库pull报错"></a>解决gerrit仓库pull报错</h3><p>如果远程的git仓库有使用到gerrit，有可能会遇到git版本与gerrit版本不一致导致的错误。则需要使用如下指令：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GIT_SSH_COMMAND=&apos;ssh -o KexAlgorithms=+diffie-hellman-group1-sha1&apos;</span><br></pre></td></tr></table></figure>
<h3 id="查看文件的提交历史"><a href="#查看文件的提交历史" class="headerlink" title="查看文件的提交历史"></a>查看文件的提交历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --filename 通过log指令来查看具体文件提交的历史记录</span><br><span class="line">git show commitid:filename 查看具体提交环节指定文件的内容</span><br></pre></td></tr></table></figure>
<h3 id="暂存工作台（stash）"><a href="#暂存工作台（stash）" class="headerlink" title="暂存工作台（stash）"></a>暂存工作台（stash）</h3><p>当目前项目中有一些未完成的工作，由于不是完成态提交会影响别人没有必要提交的内容，可以先进行缓存，来继续别的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash save 保存当前未commit的内容到stash  </span><br><span class="line">git stash list 查看所有暂存到stash的记录列表  </span><br><span class="line">git stash apply stash@&#123;index&#125; 根据list中罗列的暂存记录索引来恢复到暂存前的状态</span><br><span class="line">git stash pop  恢复stash最近暂存的记录，并删除</span><br><span class="line">git stash drop 删除stash最近暂存的记录</span><br><span class="line">git stash claer 清空stash</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="小磊砸" />
            
              <p class="site-author-name" itemprop="name">小磊砸</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小磊砸</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://xiaoleiza.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
