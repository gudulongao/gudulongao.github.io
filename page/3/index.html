<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="小磊砸的布劳格">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="小磊砸的布劳格">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小磊砸的布劳格">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>小磊砸的布劳格</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小磊砸的布劳格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/09/concurrency-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/09/concurrency-2/" itemprop="url">高并发并行基础概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-09T17:02:19+08:00">
                2018-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/09/concurrency-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/09/concurrency-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h1><ul>
<li>程序：指令和数据的描述（指令+数据）  </li>
<li>进程：操作系统进行系统资源分配的基本单位。进程是程序的实体（程序运行起来就是一个进程）。  </li>
<li>线程：程序最小的执行单位，即进程中可以包含多个线程，进程是线程的容器。<br><strong>线程的切换以及调度的成本比多进程小。</strong></li>
</ul>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p><img src="/2018/09/09/concurrency-2/thread-state.png" alt="hashtable">  </p>
<p>在Thread的源码中有定义线程状态的枚举。可以看到线程有以下几个状态：  </p>
<ul>
<li>NEW：刚刚创建线程。<strong>等待调用strat方法开始运行。</strong></li>
<li>RUNNABLE：线程正在运行。  </li>
<li>BLOCKED：当遇到同步代码块会阻塞，线程会暂停执行，直到获取锁。  </li>
<li>WAITING：无时间限制的等待。（<strong>wait等待notify，join等待目标线程执行结束</strong>）  </li>
<li>TIMED_WAITING：有时常的等待。  </li>
<li>TREMINATED：终止。  </li>
</ul>
<h1 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h1><p>终止线程的时候可以使用stop方法，但不建议使用，因为stop停止线程会让线程暴力结束，这样如果线程没有完成当前工作，比如写文件，还没有写完就被终止，这时候文件是个半成品，会造成后续的数据错误。所以对于线程如果需要终止，可以在线程中增加一个标记，通过标记来判断是否还需要继续运行。外部通过修改这个标记的值来手工达到终止线程运行的效果。</p>
<h1 id="wait-notify-notifyall"><a href="#wait-notify-notifyall" class="headerlink" title="wait/notify/notifyall"></a>wait/notify/notifyall</h1><p><img src="/2018/09/09/concurrency-2/object.png" alt="hashtable">  </p>
<p>Object对象中都包含wait和notify的方法。<strong>注意这一对方法是在Object对象中的。</strong><br>使得当前线程进入该对象的等待队列中，直到该对象调用notify方法才会从等待队列中出来。<strong>但线程是否能够继续从等待的位置继续运行，还要看线程是否能重新获取到锁。只有重新获取到锁以后才能继续执行</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package demo.basic.waitnotify;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * wait &amp; notify 样例</span><br><span class="line"> */</span><br><span class="line">public class WaitNotifyDemo &#123;</span><br><span class="line">    public static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    static class Thread1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;:&quot; + Thread.currentThread().getName() + &quot; start !&quot;);</span><br><span class="line">            //线程竞争锁</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:&quot; + Thread.currentThread().getName() + &quot; get lock !&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + &quot;:&quot; + Thread.currentThread().getName() + &quot; wait !&quot;);</span><br><span class="line">                    /**</span><br><span class="line">                     * @see 通过锁lock的wait方法，是的当前 线程进入了一个竞争锁lock的队列。只有当锁再次调用notify方法时会队列中随机一个线程唤醒</span><br><span class="line">                     */</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //唤醒的线程如果还能拿到锁，则还会继续执行</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:&quot; + Thread.currentThread().getName() + &quot; be  notify !&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Thread2 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;:&quot; + Thread.currentThread().getName() + &quot; start !&quot;);</span><br><span class="line">            //线程竞争锁</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:&quot; + Thread.currentThread().getName() + &quot; notify !&quot;);</span><br><span class="line">                //从等待锁lock的队列中随机唤醒一个线程</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testWaitNotify() &#123;</span><br><span class="line">        Thread1 thread1 = new Thread1();</span><br><span class="line">        Thread2 thread2 = new Thread2();</span><br><span class="line">        thread1.start();</span><br><span class="line">//        thread2.start();</span><br><span class="line">        //主线程sleep一秒后再启动线程2保证线程1先执行避免线程1执行后wait就再没有线程来唤醒</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.start();</span><br><span class="line">//        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testWaitNotify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从样例代码中可以看到，两个线程共享了对象lock，每次在wait操作和notify操作的时候都首先需要获取到lock的锁，<strong>wait/notify的操作都必须保证在同步代码块中</strong>。同时也可以想到当线程1中lock执行wait之后，线程1就进入了lock对象的等待线程队列中了，这个时候线程1也就释放了lock的锁。这样线程2才有机会获取到lock的锁，从而通过lock调用notify来让暂停的线程1从lock的等待线程队列中出来。这个时候线程1还需要再次竞争lock的锁才能从等待的位置继续执行。</p>
<h2 id="suspend-resume"><a href="#suspend-resume" class="headerlink" title="suspend/resume"></a>suspend/resume</h2><p>Thread提供实例方法suspend来暂停当前线程，并不会释放锁，知道当前线程调用resume才会重新激活继续执行。<br><strong>这一对方法目前已经废弃</strong></p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>suspend之后，不会释放锁</li>
<li>一旦resume先于suspend执行，即suspend之后再也没有resume操作，当前线程会一直挂起。并且不会释放其占有的资源，从而影响别的线程。  </li>
</ul>
<h2 id="与Sleep的区别"><a href="#与Sleep的区别" class="headerlink" title="与Sleep的区别"></a>与Sleep的区别</h2><ul>
<li>wait操作必须在同步代码块中，同时会释放锁，而且wait方法是Object的实例方法。</li>
<li>sleep只是让线程暂停一定时长，是Thread的静态方法，并不会释放资源（<strong>躺下睡赖着不走</strong>）。</li>
</ul>
<h1 id="join"><a href="#join" class="headerlink" title="join"></a>join</h1><p>Thread的实例方法，会阻塞当前线程，直到目标线程运行完毕。<strong>其实质等同于当前线程进入目前线程的等待线程队列（wait操作），直到目前线程执行完毕后当前线程再继续</strong>。</p>
<h1 id="yeild"><a href="#yeild" class="headerlink" title="yeild"></a>yeild</h1><p>Thread的静态方法，当前线程主动让出CPU，这样多线程会重新开始竞争CPU，所以当线程调用yeild之后，还是有可能又是其获取到CPU继续执行。</p>
<blockquote>
<p><strong>对于某些线程的工作并不重要，优先级不高，害怕其占用太多CPU资源，可以时常通过yeild方法，给予其他线程更多的工作机会</strong></p>
</blockquote>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>在start方法之前通过setDaemon(true)来设置线程为守护线程。<strong>当所有的用户线程都结束，守护线程才会结束，jvm才会停止</strong></p>
<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p><img src="/2018/09/09/concurrency-2/优先级.png" alt="hashtable">  </p>
<p>通过实例方法setPriority来设置优先级。java中通过1到10来表示线程的优先级，数值越大的优先级越高。优先级越高越容易赢得资源的竞争。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>《实战java 高并发程序设计》葛一鸣 郭超 编著</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/08/java-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/08/java-2/" itemprop="url">关键词笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-08T23:33:28+08:00">
                2018-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/08/java-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/08/java-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h1><p>主要用于修饰已支持序列化的类的属性，表明该属性不支持序列化。<br><strong>不想在网络传输中涉及的敏感信息或者一些信息不想被持久化，这些信息只想存在于使用法的内存中。</strong></p>
<ul>
<li>transient修饰实例变量。  </li>
<li>静态变量，不用transient修饰也是无法支持序列化的。  </li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://blog.csdn.net/u013207877/article/details/52572975" target="_blank" rel="noopener">https://blog.csdn.net/u013207877/article/details/52572975</a></p>
</blockquote>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>多线程会共享JVM的堆空间，对于共享资源都在JVM的主堆空间中，而多线程之间的共享资源，都会在线程自己的工作空间中有一份拷贝副本。volatile关键词的作用是对于多线程不再工作空间拷贝主堆空间的共享资源，而是直接使用主堆中的共享资源，这样解决了多线程并发时共享资源的可见性。</p>
<blockquote>
<p>根据编译器优化原则，如果不使用volatile申明变量，那么这个变量被修改后，其他线程可能并不会被通知到，甚至在别的线程中，看到变量的顺序都会是反的。但一旦使用volatile，虚拟机就会特别小心地处理这种情况。</p>
</blockquote>
<p>感觉volatile关键词主要保证了共享资源在多线程中的可见性，对有序性也有所帮助。</p>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《实战java 高并发程序设计》葛一鸣 郭超 编著</p>
</blockquote>
<h1 id="synchronzied"><a href="#synchronzied" class="headerlink" title="synchronzied"></a>synchronzied</h1><blockquote>
<p>指定对象加锁：进入同步代码块钱要活的给定对象的锁。<br>直接作用于实例方法：相当于对当前实例加锁，进入同步代码块前要获得当前实例的锁。<br>直接作用于静态方法：相当于对当前类加锁，进入同步代码块钱要获得当前类的锁。</p>
</blockquote>
<p>前两点都好理解，对于修饰静态方法的场景，这种就符合在多线程并发的时候，多线程共享的如果不是同一个对象但是同一种类型的时候，可以直接修饰在静态方法上，这样也能让线程有序执行。</p>
<h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《实战java 高并发程序设计》葛一鸣 郭超 编著<br>synchronized关键词：<a href="https://blog.csdn.net/mingyundezuoan/article/details/79264644" target="_blank" rel="noopener">https://blog.csdn.net/mingyundezuoan/article/details/79264644</a><br>synchronized与happen-before：<a href="https://www.jianshu.com/p/d53bf830fa09" target="_blank" rel="noopener">https://www.jianshu.com/p/d53bf830fa09</a>  </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/07/concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/07/concurrency/" itemprop="url">高并发基础概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-07T23:50:58+08:00">
                2018-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/07/concurrency/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/07/concurrency/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h1><ul>
<li>同步：调用方必须阻塞等待方法的返回后方可继续执行后续操作。</li>
<li>异步：调用方调用后无需等待方法的返回，方法会在另一个线程去执行，整个异步执行的过程是不会影响调用法的继续工作。  </li>
</ul>
<h1 id="并发（Concurrency-并行（Parallelism）"><a href="#并发（Concurrency-并行（Parallelism）" class="headerlink" title="并发（Concurrency)/并行（Parallelism）"></a>并发（Concurrency)/并行（Parallelism）</h1><p><img src="/2018/09/07/concurrency/concurrency-parallelism.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示：  </p>
<ul>
<li>并发：多个任务交替执行。<strong>逻辑上的同时执行</strong>。  </li>
<li>并行：多个任务同时执行。<strong>物理上的同时执行</strong>。</li>
</ul>
<h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>可被多个线程共享的资源。但是临界区的资源每次只能被一个线程独占。一旦临界区资源已被占用，其余线程只能等待。</p>
<h1 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h1><p>描述多线程的一种并发级别。  </p>
<ul>
<li>阻塞：有线程进入临界区资源，其余的线程想要进入临界区，只能等待，等待会导致线程挂起。这种会有线程挂起的并发场景就是阻塞。</li>
<li>非阻塞：即多线程并发时不会有线程导致其他线程挂起。</li>
</ul>
<h1 id="死锁-饥饿-活锁"><a href="#死锁-饥饿-活锁" class="headerlink" title="死锁/饥饿/活锁"></a>死锁/饥饿/活锁</h1><ul>
<li>死锁：每个线程都拥有别的线程继续执行的资源而有无法释放已拥有的资源，导致线程之间互相等待。</li>
<li>饥饿：时有的线程总是无法获取临界区资源，导致其无法继续执行。</li>
<li>活锁：线程间保持‘谦让’,即每个线程都主动释放临界资源，而导致资源在线程间来回跳动，<strong>没有一个线程可以同时拿到所有的资源继续执行</strong>。</li>
</ul>
<h1 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h1><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><ul>
<li><strong>阻塞要求只有一个线程能够进入临界区</strong></li>
</ul>
<p>线程在执行前，都需要先对临界区进行加锁，而其他线程由于临界区加锁而无法继续执行导致挂起。我们常用的synchronized和ReetranLock都是阻塞锁。  </p>
<h2 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h2><ul>
<li><strong>无饥饿要求每个线程都能有机会进入临界区</strong></li>
</ul>
<p>线程之间的优先级会导致并发的时候产生饥饿问题，而无饥饿的并发级别是指使用公平锁，即所有的线程都是平等的没有优先级的。  </p>
<h2 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h2><ul>
<li><strong>无障碍要求多线程并发时至少有一个线程能成功执行（走出临界区）。</strong>  </li>
<li><strong>无障碍的并发级别可行的方案就是采用CAS策略。</strong></li>
</ul>
<p>每个线程都可以访问临界区资源，都可以做修改，但是修改提交时有可能因为临界区资源已被修改导致的冲突而回滚。即线程提交修改时如果没有冲突则成功提交否则需要回滚修改，直到提交成功才可以走出临界区。<br>无障碍是一种乐观锁，这种乐观锁的极端情况就是可能没有一个线程能够成功提交修改，都在不停的回滚。  </p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><ul>
<li><strong>要求至少一个线程能在有限步内走出临界区</strong></li>
<li><strong>其余线程可以饥饿。</strong></li>
</ul>
<p>一般无锁的调用会采用一个死循环，不断尝试提交修改，如果总是不能成功提交，则产生饥饿，如果成功提交，则满足在有限步内走出临界区。  </p>
<h2 id="无等待"><a href="#无等待" class="headerlink" title="无等待"></a>无等待</h2><ul>
<li><strong>要求每个线程都能在有限步内走出临界区</strong>。</li>
</ul>
<p>常用的方式是<strong>RCU(Read Copy Update)</strong>，即对读操作的线程不加锁，这样所有的读操作线程不会阻塞也不会冲突，而对于写线程在修改数据的时候，先获取数据的副本，修改数据的副本，等待合适的时机将副本数据回写同步到数据。这样写线程也没有阻塞和冲突也都能在有限步内完成工作走出临界区。</p>
<h1 id="高并发操作的线程要求"><a href="#高并发操作的线程要求" class="headerlink" title="高并发操作的线程要求"></a>高并发操作的线程要求</h1><p><img src="/2018/09/07/concurrency/memory.png" alt="包装生成线程安全的hashmap"><br>如图所示，jvm中多线程的内存模型。在jvm中多线程都是共享堆空间。每一个线程都有自己的内存空间。每一个线程内存空间有共享资源的副本。<br>个人理解：<strong>基于RCU原理，线程每次对共享资源的修改其实都是在修改线程内共享资源的副本，为了使得共享资源能够在多线程中共享，需要考虑能够让线程内的副本的修改同步到主内存的共享资源，其余资源也要能知道共享资源发生变化，这就是需要考虑线程的可见性。</strong></p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>共享资源在被多线程并发操作的时候，每一个线程的操作都必须是原子的，共享资源的结果不会在一个线程做操作的时候因为收到别的线程而导致错误。</p>
<blockquote>
<p>比方说共享的对象是Long型的数据，多线程对其累加修改数据，在32位的系统中，对Long型的数据修改不具备原子性，有可能一个线程只修改这个64位数据的其中32位，而另一个线程则读取了修改了一半的数据，进行累加，这个结果势必就是错误的。这种错误的数据就是因为两个线程对数据的操作没有达到原子性。</p>
</blockquote>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>多线程并发时，一旦有线程修改了共享数据，其余线程能够立刻知道修改。</p>
<ul>
<li><strong>可以通过volatile来修饰共享数据，这样保证多线程之前数据的可见性</strong>。</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>jvm因为效率的问题，会发生指令重排，即实际执行的指令顺序与编写的代码顺序可能会不一致。而为了能够让多线程并发时的顺序符合我们的预期，则需要多线程能够有序执行，需要满足<strong>happen-before原则</strong>。</p>
<h3 id="happen-before原则（保证有序性）"><a href="#happen-before原则（保证有序性）" class="headerlink" title="happen-before原则（保证有序性）"></a>happen-before原则（保证有序性）</h3><ul>
<li>程序顺序原则：一个线程内保证语义的串行性。</li>
<li>volatile规则：volatile的写优先于读，这保证了volatile变量在多线程中的可见性。</li>
<li>锁规则：解锁必然发生在随后的加锁前（不会将加锁指令重排到解锁之前）。</li>
<li>传递性：A先于B，B先于C，则A先于C。</li>
<li>线程的start()优先于它的每一个动作。</li>
<li>线程的所有操作优先于线程的终结。</li>
<li>线程的终中断先于被中断线程的代码（现有线程中断，才有线程被中断）。</li>
<li>对象的构造优先于finalize。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>《实战java 高并发程序设计》葛一鸣 郭超 编著<br>死锁：<a href="https://blog.csdn.net/changfengxia/article/details/80313822" target="_blank" rel="noopener">https://blog.csdn.net/changfengxia/article/details/80313822</a><br>活锁：<a href="https://blog.csdn.net/yysct2005/article/details/38581395" target="_blank" rel="noopener">https://blog.csdn.net/yysct2005/article/details/38581395</a>    </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/CAS策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/CAS策略/" itemprop="url">CAS策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T22:33:08+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/06/CAS策略/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/06/CAS策略/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通常为了保护临界区资源的安全访问，都会通过synchronized或者ReetranLock来对资源先进行加锁。这种悲观锁会导致没有获得锁的线程阻塞。将并行改为串行，大大降低了系统的吞吐量。<br><strong>CAS(Compare and Swap)即比较交换</strong>。是无锁安全访问临界资源的一种策略。其假设访问临界资源不会有冲突，多线程对临界资源的访问无需加锁也无需等待阻塞。<strong>每个线程都可以访问临界区资源，也都可以对临界区资源进行修改，但修改不能提交。需要通过CAS算法来甄别是否有冲突，如果没有，则提交修改，如果有则重复当前操作直到没有冲突为止。</strong></p>
<h1 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h1><p>CAS参数：  </p>
<ul>
<li>V要更新的变量值</li>
<li>E该变量的期待值  </li>
<li>N该变量的新值<br>只有当 V = E 的时候，才会将V更新到N，如果V != E，则表明该变量已被修改。本次修改无法提交。</li>
</ul>
<h1 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h1><p>jdk中有一个atomic包来支持CAS处理并发操作。</p>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><ul>
<li>Unsafe提供了一系列原子性的方法来支撑CAS策略，很多数据结构例如AtomicInteger，ConcurrentLinkedQueue等，都是通过Unsafe的原子性操作来支持并发操作。</li>
<li>Unsafe底层是使用C++来实现的，并且JDK也不建议开人人员直接使用unsafe来操作。</li>
</ul>
<p><img src="/2018/09/06/CAS策略/unsafe.png" alt="包装生成线程安全的hashmap"></p>
<blockquote>
<p>当调用Unsafe.getUnsafe()方法来获取Unsafe的时候会对调用方的类加载器进行检查。一般应用的类加载器都是由AppLoader来加载，而系统代码的加载都是由Bootstrap来加载，通过Bootstrap来加载的时候getClassLoader会返回空，而通过AppLoader加载的非空，这样就拒绝了开发人员在代码中自行获取Unsfae。</p>
</blockquote>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p><img src="/2018/09/06/CAS策略/atomicinteger源码.png" alt="包装生成线程安全的hashmap"></p>
<p>如图是AtomicInteger的源码，可以看到实际存储数据的value和CAS策略实际实现Unsafe。  </p>
<ul>
<li>value字段是被volatile关键词修饰的，这样可以保证在多线程并发操作时数据的可见性。  </li>
<li>valueOffset value数据位于AtomicInteger对象中的偏移量。实际对数据的获取以及修改都是基于偏移量来获取的，直接通过偏移量来处理个人理解应该是比较高效。</li>
</ul>
<p><img src="/2018/09/06/CAS策略/atomicinteger.png" alt="包装生成线程安全的hashmap"></p>
<p>如图，是通过AtomicInteger来处理1000个并发线程处理将一个初始值0自增的过程。每个线程调用方法getAndIncrement来实现对临界资源进行自增。输出结果为1000显示整个并发操作的线程安全。<br>除了样例中的方法，AtomicInteger常用的方法如下表：  </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>get()</td>
<td>获取当前值</td>
</tr>
<tr>
<td>set(int newValue)</td>
<td>设置当前值</td>
</tr>
<tr>
<td>int getAndSet(int newValue)</td>
<td>设置新值并返回旧值</td>
</tr>
<tr>
<td>boolean compareAndSet(int expect,int newValue)</td>
<td>如果当前值为except，则更新为newValue</td>
</tr>
<tr>
<td>int getAndIncreament()</td>
<td>自增1，返回旧值</td>
</tr>
<tr>
<td>int getAndDecrement()</td>
<td>自减1，返回旧值</td>
</tr>
<tr>
<td>int getAndAdd(int data)</td>
<td>增加data，返回旧值</td>
</tr>
<tr>
<td>int increamentAndGet()</td>
<td>自增1并返回新值</td>
</tr>
<tr>
<td>int decrementAndGet()</td>
<td>自减1并返回新值</td>
</tr>
<tr>
<td>int addAndGet(int data)</td>
<td>增加data并返回新值</td>
</tr>
</tbody>
</table>
<h2 id="AtomicStampedReference（解决AAB问题）"><a href="#AtomicStampedReference（解决AAB问题）" class="headerlink" title="AtomicStampedReference（解决AAB问题）"></a>AtomicStampedReference（解决AAB问题）</h2><p>CAS策略在控制并发的时候很重要的一点是将期望值与当前值进行比对。如果一致则认为没有其他线程修改，当前修改可以提交，但如果数据从A修改为B又被修改为A，实际是发生了修改但数据一致，如果业务需求需要并发控制的时候不仅仅是通过数值的一致来判断，那么就需要使用到AtomicStampedReference，<strong>即每次修改的时候不仅仅是修改value数据区域，同时还有时间戳，每次进行比对的时候也不仅仅是比对value，还要比对时间戳。只有当时间戳和value都符合期望的时候，修改可以提交。</strong></p>
<p><img src="/2018/09/06/CAS策略/atomicstampedreference.png" alt="包装生成线程安全的hashmap"></p>
<p>如图中源码的compareAndSet方法，除了expectValue，还有expectStamped。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="/2018/09/06/CAS策略/other.png" alt="包装生成线程安全的hashmap"></p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><blockquote>
<p> 网络博客：<a href="https://blog.csdn.net/liubenlong007/article/details/53761730" target="_blank" rel="noopener">https://blog.csdn.net/liubenlong007/article/details/53761730</a><br>《实战java 高并发程序设计》葛一鸣 郭超 编著</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/collect-线程安全的hashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/collect-线程安全的hashmap/" itemprop="url">线程安全的HashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T23:28:24+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/collect-线程安全的hashmap/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/collect-线程安全的hashmap/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p><img src="/2018/09/05/collect-线程安全的hashmap/hashtable.png" alt="hashtable">  </p>
<p>HashTable是线程安全的map，其对所有的get/put方法都通过synchronized关键词来保证线程安全。由于关键词synchronized修饰的是方法，所以线程在执行get/put操作时都会需要获取到这个map对象锁。效率低</p>
<h1 id="Collections-synchronizedMap"><a href="#Collections-synchronizedMap" class="headerlink" title="Collections.synchronizedMap"></a>Collections.synchronizedMap</h1><p><img src="/2018/09/05/collect-线程安全的hashmap/包装.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示，通过Collections.synchronizedMap可以将hashmap包装成一个线程安全的hashmap。</p>
<p><img src="/2018/09/05/collect-线程安全的hashmap/synchronizedmap.png" alt="包装生成线程安全的hashmap"></p>
<p>对于synchronziedMap其实也是基于synchronized来保证的线程安全性，在所有的方法操作之前都需要获取mutex对象锁。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="1-7版"><a href="#1-7版" class="headerlink" title="1.7版"></a>1.7版</h2><p><img src="/2018/09/05/collect-线程安全的hashmap/concurrenthashmap.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示，concurrenthashmap主要由segemtn,entry和链表构成。concurrenthashmap本质是一个segment数组，每一个segment对应着一个Entry数组，Entry数组中的每一个Entry节点都是一个单向链表的头节点。</p>
<h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><p>Segment继承自<strong>ReentranLock</strong>。故Segment其实就是一个锁，Segment是其对应的Entry数组(table)的线程安全的保证。即每当要对Segment对应的table进行操作首先要对Segment加锁。  </p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>每一个Segment都有一个count属性，被<strong>volatile</strong>修饰的。这样每当有线程造成对table的结构性修改都会立即可见。其记录着Segment所包含的HashEntry个数，</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>每一个Segment对应着一个table，被<strong>volatile</strong>修饰。这样每当有线程造成对table的结构性修改都会立即可见。</p>
<h3 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V value;</span><br><span class="line">        final  volatile HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>
<p>HashEntry是Segment中的所有元素的抽象。其value和next都是由volatile修饰的，<strong>由于value和next都被volatile修饰，故每次线程都能读取到最新的数据，所以concurrenthashmap的读操作并没有加锁</strong>。<br>由于next被final修饰，故当有冲突时，节点都从链表的头插入，</p>
<h3 id="concurrencyLevel"><a href="#concurrencyLevel" class="headerlink" title="concurrencyLevel"></a>concurrencyLevel</h3><p>并发度就是concurrenthashmap理想可以支持并发线程数，即Segment的个数。<strong>concurrencyLevel默认是16，concurrentHashMap理想支持16个线程并发操作</strong>。</p>
<h3 id="计算key所在的Segment位置"><a href="#计算key所在的Segment位置" class="headerlink" title="计算key所在的Segment位置"></a>计算key所在的Segment位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Returns the segment that should be used for key with given hash</span><br><span class="line">  * @param hash the hash code for the key</span><br><span class="line">  * @return the segment</span><br><span class="line">  */</span><br><span class="line"> final Segment&lt;K,V&gt; segmentFor(int hash) &#123;</span><br><span class="line">     return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>方法segmentFor就是根据key的hash值来计算key所处的Segment位置，其中SegmentShift=log(size)以2为底。segmentMask=concurrencyLevel-1。</p>
<h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p><img src="/2018/09/05/collect-线程安全的hashmap/concurrencyhashmap1.8.png" alt="包装生成线程安全的hashmap"></p>
<p>如图所示。在JDK1.8版本中，对ConcurrentHashMap做了很大的调整。去除了Segment分段锁的设计。采用Node结构，结合单向链表和红黑树来解决冲突（当冲突链表中数据个数大于8个自动将链表转化成红黑树，<strong>查询效率有O(n)降低到O(logn)</strong>，当红黑树的节点个数小于6再转化成链表）。</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">   final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">   	  //参数盘空</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       //重算key的哈希值</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">       //死循环，直到成功put才会结束循环（配合CAS策略）</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">           //如果table为空，则初始化table，concurrenthashmap的构造函数并不会初始化</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">               tab = initTable();</span><br><span class="line">           //如果指定位置为空，则表明没有发生冲突，直接在table中增加节点（tabAt和casTabAt都是通过Unsafe的CAS操作）</span><br><span class="line">           else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">               if (casTabAt(tab, i, null,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                   break;                   // no lock when adding to empty bin</span><br><span class="line">           &#125;</span><br><span class="line">           //正在扩容，则帮助扩容。</span><br><span class="line">           else if ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           else &#123;</span><br><span class="line">               V oldVal = null;</span><br><span class="line">               //对指定位置的Node（头节点）加锁（注意使用的是synchronized来加锁）</span><br><span class="line">               synchronized (f) &#123;</span><br><span class="line">                   //比较头节点</span><br><span class="line">                   if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       if (fh &gt;= 0) &#123;</span><br><span class="line">                           binCount = 1;</span><br><span class="line">                           //遍历链表，找到尾部插入新节点</span><br><span class="line">                           for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               if (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   if (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               if ((e = e.next) == null) &#123;</span><br><span class="line">                                   pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, null);</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       //遍历红黑树，插入新节点</span><br><span class="line">                       else if (f instanceof TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = 2;</span><br><span class="line">                           if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != null) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               if (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               //如果链表的节点数达到需要转换成红黑树的阀值，在转换成红黑树</span><br><span class="line">               if (binCount != 0) &#123;</span><br><span class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   if (oldVal != null)</span><br><span class="line">                       return oldVal;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(1L, binCount);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过put方法的源码可以发现：  </p>
<ul>
<li>通过synchronized来对链表的头节点Node进行加锁。而没有使用1.7版本中的ReentranLock。  </li>
<li>整个concurrentHashMap的初始化是发生在第一次put的时候。  </li>
<li>指定位置节点的获取，更新以及增加的操作都是通过Unsafe利用CAS策略来实现的，这种无锁的处理方式减少了因为锁导致的线程阻塞，增大了系统的吞吐量。</li>
</ul>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        //重算key的哈希值</span><br><span class="line">        int h = spread(key.hashCode());</span><br><span class="line">        //获取指定位置的Node（无冲突时链表的头节点）判断如果一致则返回</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">            if ((eh = e.hash) == h) &#123;</span><br><span class="line">                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果是扩容，则通过ForwardingNode查找</span><br><span class="line">            else if (eh &lt; 0)</span><br><span class="line">                return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">            //依次遍历查找</span><br><span class="line">            while ((e = e.next) != null) &#123;</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过get方法的源码，可以看出,get方法并没有加锁。</p>
<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p><img src="/2018/09/05/collect-线程安全的hashmap/8-cas.png" alt="包装生成线程安全的hashmap"></p>
<p>如图中所示，在1.8版的ConcurrentHashMap中还是使用到了CAS策略，通过Unsafe来完成获取指定位置的Node，通过比较交换来设置指定位置的Node以及增加对应位置的Node。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>1.8版本的锁颗粒度更小，只是对Node数组中的Node节点通过synchronized来加锁。而1.7版本中是对整个Segment来加锁。  </li>
<li>1.8中除了通过链表来解决冲突之外，当链表中节点的个数大于8个之后会转换成红黑树，这样使得当有冲突时查找数据的效率由O(n)降低到了O(logn)。<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li>
</ul>
<blockquote>
<p> <a href="https://blog.csdn.net/justloveyou_/article/details/72783008" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/72783008</a><br> <a href="https://blog.csdn.net/bolang789/article/details/79855053" target="_blank" rel="noopener">https://blog.csdn.net/bolang789/article/details/79855053</a><br> <a href="https://blog.csdn.net/fouy_yun/article/details/77816587" target="_blank" rel="noopener">https://blog.csdn.net/fouy_yun/article/details/77816587</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/java-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/java-1/" itemprop="url">PO/BO/VO/POJO/DAO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T16:06:34+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/java-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/java-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PO-VO-BO-DAO-简介"><a href="#PO-VO-BO-DAO-简介" class="headerlink" title="PO/VO/BO/DAO 简介"></a>PO/VO/BO/DAO 简介</h1><h2 id="PO（Presistant-Object）"><a href="#PO（Presistant-Object）" class="headerlink" title="PO（Presistant Object）"></a>PO（Presistant Object）</h2><p>持久化对象，数据库中数据的抽象，即对应表中的一条记录。</p>
<h2 id="BO-Business-Object"><a href="#BO-Business-Object" class="headerlink" title="BO(Business Object)"></a>BO(Business Object)</h2><p>业务对象，可以包含多个其他对象。</p>
<blockquote>
<p>一份简历，包含教育经历，工作经历等，教育经历对应一个PO，工作经历对应一个PO，这样简历BO就由这些PO组成。</p>
</blockquote>
<h2 id="DTO-Data-Transfer-Object"><a href="#DTO-Data-Transfer-Object" class="headerlink" title="DTO(Data Transfer Object)"></a>DTO(Data Transfer Object)</h2><p>数据传输对象，用于前端与后端进行数据交互。由于涉及到网络传输，故DTO会根据展示层的要求来简化数据来减少网络流量。</p>
<blockquote>
<p>比如一个表有20个字段，对应的PO也会有20个字段，界面展现只需要展现5个字段，故只需要DTO包含界面展现的5个字段进行传输即可，相比较传输真个PO，这样减少了网络流量，也不会暴露整个表结构。</p>
</blockquote>
<h2 id="VO-Value-Object"><a href="#VO-Value-Object" class="headerlink" title="VO(Value Object)"></a>VO(Value Object)</h2><p>值对象，常用于前端组件进行数据展现的时候所使用的数据结构。其来自于DTO。</p>
<h2 id="POJO-plain-ordinary-java-object"><a href="#POJO-plain-ordinary-java-object" class="headerlink" title="POJO(plain ordinary java object)"></a>POJO(plain ordinary java object)</h2><p>简单的java对象。普通的javabean。</p>
<h1 id="区别与应用"><a href="#区别与应用" class="headerlink" title="区别与应用"></a>区别与应用</h1><h2 id="VO与DTO"><a href="#VO与DTO" class="headerlink" title="VO与DTO"></a>VO与DTO</h2><p>当展现层的需求只有一种的时候，可以使用DTO来替代VO，在设计层面，DTO只是用来明确服务端接收的请求的数据或者响应请求的数据，而界面展现的时候，特别是当展现的需求多种多样的时候，会基于同一种DTO而衍生出不同的VO。</p>
<blockquote>
<p>比方说性别，DTO中sex是男女，如果普通的展现需求，可以直接利用DTO中的sex属性来展现。但如果有个性化定制的时候，比方说需要展现成帅哥/美女，这种时候基于同样的DTO就需要根据展现的需求来衍生出性别为帅哥/美女的VO。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/collect-hashmap-hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/collect-hashmap-hashtable/" itemprop="url">HashMap与HashTable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T13:49:37+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/collect-hashmap-hashtable/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/05/collect-hashmap-hashtable/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HasMap"><a href="#HasMap" class="headerlink" title="HasMap"></a>HasMap</h1><ul>
<li>HashMap是基于哈希表实现的。每一个元素都是key-value的键值对。并通过链表来解决冲突问题。  </li>
<li>HashMap是非线程安全的。可以利用<strong>Collections.synchronizedMap</strong>来获取经过线程安全包装的HashMap。  </li>
<li>HashMap实现了Serializable接口，支持克隆。</li>
<li>HashMap默认大小是16（<strong>必须是2的整次幂</strong>），加载因子默认是0.75，即当已使用当前容量的0.75后，HashMap会自动扩容（2倍）。容量大小和加载因子都可以在构造的时候指定。</li>
<li>HashMap允许添加的元素key，value为空。</li>
</ul>
<h2 id="存储逻辑"><a href="#存储逻辑" class="headerlink" title="存储逻辑"></a>存储逻辑</h2><p>HashMap底层是一个Entry的数组。并利用链表来解决冲突，即没有个Entry是链表的头部节点。每一次添加一个key-value元素时，基于key的哈希值和HashMap的大小来计算出元素所位于Entry数组的位置索引（key的哈希值&amp;&amp;0x7FFFFFFF，<strong>为了去除哈希值的符号</strong>，再与size取模），如果两个元素计算出的位置索引一致，则会将元素添加到同一个entry下的链表中。<br><img src="/2018/09/05/collect-hashmap-hashtable/hashmap-struct.png" alt="HashMap存储结构"><br>如图，紫色部分是Enty数组，绿色部分时用来解决冲突的链表。</p>
<h2 id="扩容逻辑"><a href="#扩容逻辑" class="headerlink" title="扩容逻辑"></a>扩容逻辑</h2><p>当HashMap的使用空间=当前容量*加载因子后，HashMap会自动扩容，<br>扩容会新建一个Entry数组，将已有的所有元素都重新计算位置索引并转移到新的Entry数组中。所以扩容会相当的费时。  </p>
<ul>
<li>当加载因子越小，容易进行扩容操作，能使用的空间小，也会造成大量的空间浪费。  </li>
<li>当加载因子越大，不容易进行扩容操作。空间使用率高，但冲突率会加大，链表会很长，这样查询的效率会很低。  </li>
</ul>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul>
<li>HashTable是基于哈希表实现的，也是通过链表来解决冲突。</li>
<li>HashTable是线程安全的。所有操作的方法都有Synchronized关键词修饰。</li>
<li>HashTable也实现了Serizlizable接口，支持克隆。</li>
<li>HashTable默认大小11，加载因子默认也是0.75，自动扩容为（2倍+1）。容量和加载因子可以在构造时指定。</li>
<li>HashTable不允许添加的元素key为空，源码中可以看到，当key为空时，会抛出空指针异常。<br><img src="/2018/09/05/collect-hashmap-hashtable/hashtablecode.png" alt="HashTable源码"></li>
</ul>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="继承父类不同"><a href="#继承父类不同" class="headerlink" title="继承父类不同"></a>继承父类不同</h2><p>HashMap继承自AbstractMap，HashTable继承自Dictionary。但都实现了Map接口。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>HashMap不是线程安全的，而HashTable是线程安全的。</p>
<h2 id="是否提供contains方法"><a href="#是否提供contains方法" class="headerlink" title="是否提供contains方法"></a>是否提供contains方法</h2><p>HashMap提供containsKey和containsValue两个方法，HashTable提供contains,containsKey和containsValue三个方法（containsValue中调用的contains方法）。</p>
<h2 id="key是否允许为null"><a href="#key是否允许为null" class="headerlink" title="key是否允许为null"></a>key是否允许为null</h2><p>HashMap允许key和value为null,HashTable不允许key和value为空。<strong>因此在HashMap中不能通过get方法来判断是否存在某一个key，有可能这个key就是null</strong></p>
<h2 id="哈希值的不同"><a href="#哈希值的不同" class="headerlink" title="哈希值的不同"></a>哈希值的不同</h2><p>HashMap是重新计算key的哈希值，在与0x7FFFFFFF做与运算，去除符号后与size取模来计算元素在Entry数组中的位置索引。HashTable是直接利用key的哈希值来与size取模获取位置索引。</p>
<h2 id="扩容逻辑不同"><a href="#扩容逻辑不同" class="headerlink" title="扩容逻辑不同"></a>扩容逻辑不同</h2><ul>
<li>HashMap默认大小16，HashTable默认大小11.</li>
<li>HashMap每次扩容为原有的2倍，HashTable扩容为原有的2倍+1。  </li>
<li>HashMap要求Entry数组长度必须是2的整次幂，HashTable没有要求。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/http-state-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/http-state-code/" itemprop="url">http状态码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T23:18:03+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/04/http-state-code/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/04/http-state-code/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面试的时候被问到了有关状态码的内容，现整理如下表所示：</p>
<h1 id="正在执行"><a href="#正在执行" class="headerlink" title="正在执行"></a>正在执行</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>正在执行</td>
</tr>
</tbody>
</table>
<h1 id="成功处理请求"><a href="#成功处理请求" class="headerlink" title="成功处理请求"></a>成功处理请求</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td><strong>成功返回</strong></td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>资源已依据请求创建</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td><strong>已接收请求但并未处理，异步执行，可能执行了可能没执行</strong></td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>已处理请求，但返回数据的来源非原始服务器，可能来自本地或第三方的拷贝。即<strong>非授权信息</strong></td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>处理请求后无返回数据</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>处理请求后无返回，但需要请求方需要重置文档视图（浏览器需要重置表单）</td>
</tr>
</tbody>
</table>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>被请求的资源有多个备选的操作供请求者选择，每一个操作都对应一个地址来重定向</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>被请求的资源已被永久的变更到新地址，<strong>使用get请求时会自动重定向</strong></td>
</tr>
<tr>
<td>302</td>
<td>Move temporarily</td>
<td>被请求的资源临时从别的地址来响应，请求者还是通过原有地址来请求</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>请求的资源可以在另一个URI中获取，请求者应该通过一个专门的get请求来获取响应</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>本次请求与上一次的请求，请求的网页没有变化，返回此状态码而不会返回网页数据</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>请求的资源必须通过指定的代理才可以被访问</td>
</tr>
<tr>
<td>306</td>
<td>Temporary Redirect</td>
<td>服务器临时从别的地址来响应请求，请求者还是通过原有地址来请求</td>
</tr>
</tbody>
</table>
<h1 id="请求错误"><a href="#请求错误" class="headerlink" title="请求错误"></a>请求错误</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>Bad Request</td>
<td><strong>请求参数错误/语义错误</strong></td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>需要认证</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>拒绝该请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>未找到指定的资源</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>拒绝请求的方法</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>无法使用请求的内容特性响应请求的网页</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>与401类似，但是需要在代理服务器进行身份认证</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>请求超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器在处理请求时发生冲突，需要返回详细的信息告知请求方冲突的来源</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>请求的资源已永久的不可用（已删除）</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>需要定义content length，即服务器拒绝没有定义有效长度的请求</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>未满足先决条件</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>请求的实体数据太大</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Long</td>
<td>请求的URI超长</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器不支持请求的数据格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable</td>
<td>请求中包含Range,但返回的数据中不符合在范围内</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>请求中包含Except，但服务器无法满足预期</td>
</tr>
<tr>
<td>421</td>
<td>too many connections</td>
<td>服务器的连接数超限</td>
</tr>
<tr>
<td>422</td>
<td>Unprocessable Entity</td>
<td>请求格式正确但含有语义错误</td>
</tr>
<tr>
<td>423</td>
<td>Locked</td>
<td>请求资源被锁定</td>
</tr>
<tr>
<td>424</td>
<td>Failed Dependency</td>
<td>由于之前的请求导致本次请求失败</td>
</tr>
<tr>
<td>451</td>
<td>Unavailable For Legal Reasons</td>
<td>请求因法律原因而不可用</td>
</tr>
</tbody>
</table>
<h1 id="服务器错误"><a href="#服务器错误" class="headerlink" title="服务器错误"></a>服务器错误</h1><table>
<thead>
<tr>
<th>code</th>
<th>des</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td><strong>服务器端发生异常</strong></td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持该功能，无法识别该请求或者不能支持该请求的资源</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td><strong>网关或者代理服务器在处理请求时，无法从上游服务器获取响应</strong></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td><strong>服务器维护或者过载导致无法处理请求</strong></td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td><strong>网关或代理服务器处理请求时，获取上游服务器响应超时</strong></td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器不支持请求指定的http版本</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/redis-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis-3/" itemprop="url">redis持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T22:16:00+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/redis-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/redis-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis持久化方式"><a href="#Redis持久化方式" class="headerlink" title="Redis持久化方式"></a>Redis持久化方式</h2><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>将某个时刻的数据持久化到硬盘中。用户可以对快照进行备份。支持复制到其他服务器。</p>
<h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><ul>
<li><strong>bgsave</strong> 创建一个快照。<strong>Redis会创建一个子进程来负责将快照写入硬盘。父进程继续接受请求。</strong></li>
<li><strong>save</strong> Redis在快照创建完毕前不会接受任何请求。</li>
<li><strong>shutdown</strong>命令用于停止redis服务的时候会执行一次<strong>save</strong>命令。停止所有请求。</li>
<li><strong>sync</strong>命令进行Redis服务器之间的数据同步的时候。如果主服务器并没有正在进行bgsave或者不是刚刚结束bgsave命令时会执行bgsave命令。</li>
</ul>
<h4 id="快照配置"><a href="#快照配置" class="headerlink" title="快照配置"></a>快照配置</h4><blockquote>
<p>save 60 1000    60秒内有1000次写操作则自动触发bgsave<br>stop-writes-on-bgsave-error-no  当创建快照失败时是否停止写操作<br>rdbcompression yes  是否对快照进行压缩<br>dbfilename dump.rdb 快照名称<br>dr ./   快照文件存储的路径</p>
</blockquote>
<h4 id="快照缺陷"><a href="#快照缺陷" class="headerlink" title="快照缺陷"></a>快照缺陷</h4><ul>
<li>快照是某一个时间点的内存数据备份。如果在服务器崩溃则会丢失上一次快照到崩溃时的所有变更数据。   </li>
<li>快照适合即使丢失一部分少量的数据也不会对整个应用造成问题的场景。   </li>
</ul>
<blockquote>
<p>《Redis实战》中提到的对日志进行聚合计算。没有看懂到底是什么意思。   </p>
</blockquote>
<ul>
<li>当大数据处理时，Redis占用的内存会很大，bgsave创建子进程会耗费一定的时间，这个创建的过程则会导致redis停顿。停顿的时间随着Redis占用内存越大而越久。相比较于创建子进程带来的停顿，save并不会因为要创建子进程而去争抢资源导致停顿。故save会较bgsave的速度更快。</li>
</ul>
<h3 id="AOF-append-only-file"><a href="#AOF-append-only-file" class="headerlink" title="AOF(append-only file)"></a>AOF(append-only file)</h3><p>将写操作的命令追加到备份文件中。等到需要恢复时（重启）从头到尾执行一遍备份文件中的写命令即可。</p>
<h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>随着Redis不断的运行。aof文件会变得越来越大。占用硬盘同时在重启时根据aof重新执行写命令时耗时长。<br><strong>bgrewriteaof</strong> 等同bgsave，会启动子进程来重写aof文件。父进程继续接受请求。</p>
<h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><blockquote>
<p>appendonly yes  是否启用AOF模式<br>appendfsync everrysec 追加的频率。always每次写操作都同步。everysec每秒执行一次同步，可以同步多条写操作。no 由操作系统来决定何时进行同步。<br>no-appendfsync-on-rewrite no<br>auto-aof-rewrite-percentage 100 当aof文件比上一次重写时大了一倍则进行aof文件重写<br>auto-aof-rewrite-min-size 64mb  当aof文件的大小大于64mb时进行aof文件重写<br>dr ./   aof文件存储路径     </p>
</blockquote>
<h4 id="AOF缺陷"><a href="#AOF缺陷" class="headerlink" title="AOF缺陷"></a>AOF缺陷</h4><ul>
<li><strong>bgrewriteaof</strong>命令创建子进程也会由于redis占用的内存越大而创建子进程的时间越长从而导致redis停顿。</li>
<li>对aof文件进行重写时会涉及对旧的aof文件进行删除，如果文件很大很有可能导致操作系统的挂起。</li>
</ul>
<h2 id="持久化的意义"><a href="#持久化的意义" class="headerlink" title="持久化的意义"></a>持久化的意义</h2><ul>
<li>数据重用。redis中很多的数据都是一些经过长时间计算得到的。这样持久化到硬盘中就不必再次计算可以方便下次使用。</li>
<li>安全。将数据备份到硬盘防止因系统崩溃而丢失数据。Redis运行时数据都是存储在内存中，而一旦系统奔溃内存中的数据时很大程度会丢失。  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/redis-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小磊砸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小磊砸的布劳格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis-2/" itemprop="url">redis笔记二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T22:11:37+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/redis-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/redis-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅/发布模式"></a>订阅/发布模式</h2><blockquote>
<p>一般来说，发布于订阅的特点是订阅者(listener)负责订阅频道(channel)，发送者(publisher)负责向频道发送而今这字符串消息(binary string message)。每当有消息被发送至给定的频道时，频道的所有订阅者都会受到消息。<br>by 《Redis 实战》</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel1 ...] 订阅频道  </span><br><span class="line">unsubscribe [channel [channel1 ...]] 退订频道，**如果未指定channel则默认退订所有频道。**  </span><br><span class="line">publish channel message 向频道channel发送消息  </span><br><span class="line">psubscribe pattern [pattern...] 订阅符合条件的频道  </span><br><span class="line">punsubscribe [pattern [pattern...]] 退订符合条件的频道，**如果没有指定pattern则默认退订所有频道。**</span><br></pre></td></tr></table></figure>
<h3 id="订阅-发布模式的缺陷"><a href="#订阅-发布模式的缺陷" class="headerlink" title="订阅/发布模式的缺陷"></a>订阅/发布模式的缺陷</h3><ul>
<li>系统的缺陷。旧版本的Redis。当订阅的频道消息量很大而自身的读取速度不够时会导致Redis缓冲区体积很大，这样会使得效率很低甚至崩溃。还会被操作系统强杀。新版本的Redis不会有这种问题，需要配置client-output-buffer-limit pubsub来自动断开。  </li>
<li>数据传输的可靠性。在客户端订阅过程中断线，客户端会丢失在断线期间频道的所有消息。</li>
</ul>
<h2 id="事务基本用法"><a href="#事务基本用法" class="headerlink" title="事务基本用法"></a>事务基本用法</h2><blockquote>
<p>Redis有5个命令可以让用户再不被打断的情况下对多个键执行操作，分别是watch、multi、exec、unwatch和discard。<br>Redis基本的事务用法置灰用到multi和exec命令。<br>Redis里执行事务，首先需要执行Multi命令，然后输入那些想要在事务里执行的命令，最后再执行exec命令。当</p>
</blockquote>
<p>Redis从一个客户端那里接收到multi命令时，Redis会将这个客户端之后发送的所有命令都放入到一个队列里，直到这个客户端发送exec命令为止，然后Redis就会在不被打断的情况下，一个接一个地执行存储在队列里地命令。这种事务的执行方式是通过延迟执行事务极大降低了客户端与服务端的通信连接次数来提高性能。是一种<strong>流水线事务。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi 申明后面地指令操作都在同一个事务中。    </span><br><span class="line">exec 申明事务截至，以上地所有操作都在同一个事务中。  </span><br><span class="line">watch 对键进行监控。直到exec命令之间如果有别的连接对受监控的键进行了修改，删除等更新操作，exec命令执行失败并返回错误。  </span><br><span class="line">unwatch 取消对键的监控。在执行multi之前都有效。  </span><br><span class="line">discard	取消对键的监控。在执行exec之前都有效。</span><br></pre></td></tr></table></figure>
<h3 id="Redis没有加锁"><a href="#Redis没有加锁" class="headerlink" title="Redis没有加锁"></a>Redis没有加锁</h3><p>传统数据库会在对数据库进行写操作时对访问的数据进行加锁。直到事务被提交或者回滚。其它客户端对数据进行写入时由于无法拿到数据的锁而阻塞。只有当持有锁的事务执行完毕后释放锁才可以重新执行。这种锁的缺陷是当锁的持有事务执行的时间越久，则其它事务阻塞的时间就越久<strong>（悲观锁）</strong>。<br>Redis为了尽可能的减少客户端阻塞的时间，只有当数据已经抢先被修改更新了，如果有客户段对该数据进行监控(watch)的会进行通知<strong>（乐观锁）</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="小磊砸" />
            
              <p class="site-author-name" itemprop="name">小磊砸</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小磊砸</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://xiaoleiza.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
